%\documentclass{llncs}
\documentclass[11pt]{article} % use larger type;

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)


%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\usepackage{graphicx,array}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{epsfig}
\usepackage{float}
%\usepackage{supertabular} % used in B Symbols
\geometry{a4paper} % or letterpaper (US) or a5paper or....

\include{comandos}
\include{SymbolsB_AtelierB} 
% Allow use multiples footnote references 
\newcommand{\footnoteremember}[2]{
  \footnote{#2}
  \newcounter{#1}
  \setcounter{#1}{\value{footnote}}
}
\newcommand{\footnoterecall}[1]{
  \footnotemark[\value{#1}]
}


%
\begin{document}

\title{Formal Construction of Microcontroller Instruction Set Model Using B}

\hyphenation{se-pa-ra-te}

\author{Val\'{e}rio Medeiros Jr%\inst{2}
, David D\'{e}harbe%\inst{1}
}

 %\institute{ \inst{1}Federal Institute of Education, Science and Technology of Rio Grande do Norte, Natal RN 59015-000, Brazil % } 
 %  \and %\institute{
 %  \inst{2}Federal University of Rio Grande do Norte, Natal RN 59078-970,Brazil}


\maketitle

\begin{abstract}
  [TODO:To redo]
  This paper describes an approach to model the functional aspects of
  the instruction set of microcontroller platforms using the notation
  of the B method. The paper presents specifically the case of the Z80 
  platform. This work is a contribution towards the extension of the
  B method to handle developments up to assembly level code.
\end{abstract}
%
%\keywords{Fomal Methods, microcontroller Verification, Hardware}

\section{Introduction}
[TODO:To update] 
The B method~\cite{Abrial} supports the construction of safety systems
models by verification of proofs that guarantees its correctness. So,
an initial abstract model of the system requirements is defined and
then it is refined until the implementation model. Development
environments based on the B method also include source code generators
for programming languages, but the result of this translation
cannot be compared by formal means. The paper \cite{Dantas_SBMF08} presented
recently an approach to extend the scope of the B method up to the
assembly level language. One key component of this approach
is to build, within the framework of the B method, formal models of
the instruction set of such assembly languages.

This work gives an overview of the formal modelling of the instruction
set of the Z80 microcontroller~\cite{Z80_manual}\footnote{The
  interested reader in more details is invited to visit our repository
  at: http://code.google.com/p/b2asm.}. Using the responsibility
division mechanism provided by B, auxiliary libraries of basic modules
were developed as part of the construction of microcontroller
model. Such library has many definitions about common concepts used in
the microcontrollers; besides the Z80 model, it is used by two other
microcontrollers models that are under way.

Other possible uses of a formal model of a microcontroller
instruction set include documentation, the construction of simulators,
and be possibly the starting point of a verification effort for the
actual implementation of a Z80 design. Moreover the model of the
instruction set could be instrumented with non-functional aspects,
such as the number of cycles it takes to execute an instruction, to
prove lower and upper bounds on the execution time of a routine. The
goal of this project, though, is to provide a basis for the generation
of software artifacts at the assembly level that are amenable to 
refinement verification within the B method.

This paper is focused on the presentation of modelling of assembly instruction
set, including elementary libraries to describe hardware aspects. The paper is
structured as follows. Section~\ref{sec:B_method} provides a short introduction
to the B method. Section~\ref{sec:models} presents the elementary libraries and
the modelling of some elements common to microcontrollers.  Section~\ref{sec:z80}
presents the B model of the Z80 instruction set. Section ~\ref{sec:Verification}
provides some information on the proof effort needed to analyze the presented
models. Related work is discussed in Section~\ref{sec:relatedworks}. Finally, the
last section is devoted to the conclusions.

\subsection{Problems in formalizing instruction set}
[I need review the text and move this secion to other place]
%a) Explicar como sheo formalizados os conjuntos de instruheheo nos
%manuais dos construtores (Consultar os dois manuais)

In general, the manuals of microcontrollers can be more appropriate for
developers in assembly language. Many times, each instruction of microcontrollers
are shown in its official manual using textual description, math partially
description of instruction, examples, encoding, number of cycles and others
informations. But the explantion about the action of instruction do not use
usually the better way to describe the instruction for users and developers. For example,
if the user want to know the action of instruction and its effect on the flag
register then he needs search this information in different pages of manual.
Besides, the writer of manual usually describes important facts in not formal
notation and default. So this description can add some ambiguities or until
mistakes. 


% b) The case of Z80
The official manual of the microcontroller Z80 \cite{Z80_manual} has several
problems that were identified over time~\cite{UndocumentedZ80}. The Z80 is a
microcontroller that  has been tested and used for many years. This intensive use
and test facilitated to find several errors in the description of the
instructions in its manual. Several of these problems have been cataloged in a
technical report \cite{UndocumentedZ80}. Some problems are inaccurate
information, for example the description of action of instruction on the flag
register, partial informations and distributed on different pages of manual.


Some erros was identified during the development of Z80 model.
An example is
%\begin{itemize}
% \item Some input and output instructionsThe
% INI/INIR/IND/INDR/OUTI/OUTD/OTIR/OTDR instructions do affect the CF flag (some official documentation says they leave it unaffected, important!) and the
% NF flag is not always set but may also be reset (see 4.3 for exact operation)
% \cite{UndocumentedZ80}.
% Este erro he descrito na phegina (274 do documento e 294 do pdf) 
% do manual oficial do Z80 (Z80_CPU_adotado.pdf)
% Citar apenas esse exemplo abaixo! 
%   \item
when a determined interruption (NMI) is accepted, the bit IFF1 is not
copied to bit IFF2. % Este erro he descrito na phegina (23 do documento e 41do pdf) % do manual oficial do Z80 (Z80_CPU_adotado.pdf)
Only IFF1 is reset. This problem was identified, because the description of
interruption on the official manual is big and complex, so to help the
construction of Z80 B model, others references  \cite{UndocumentedZ80,Simulator_z80} 
also were consulted.
  
%\end{itemize}

An interesting solution is to specify formally the assembly instruction set,
this creates a pattern of representation and validates properties of
instructions. The formal model also restricts the definitions to correct typing and use only
expressions well-defined.
% -> Solucao interessante he especificar  formalmente o conjunto
% de instruhehehees, isto cria um padrao formal de representaheheheo e valida propriedades
% das instrucoes. 
Furthermore, the developer can use with B method different levels of
abstraction and add more specific details in refined models. 
 

% allow to verify properties on the model.
\section{Introduction to the B Method}
\label{sec:B_method}

The B method for software development~\cite{Abrial} is based on the B Abstract
Machine Notation (AMN) and the use of formally proved refinements up to a
specification sufficiently concrete that programming code can be automatically
generated from it. Its mathematical basis consists of first order logic, integer
arithmetic and set theory, and its corresponding constructs are similar to those
of the Z notation.

A B specification is structured in modules. A module defines a set of valid
states, including a set of initial states, and operations that may provoke a
transition between states. The design process starts with a module with a
so-called functional model of the system under development. In this initial
modeling stage, the B method requires that the user proves that, in a machine,
all the its initial states are valid, and that operations do not define
transitions from valid states to invalid states.
  
Essentially, a B module contains two main parts: a header and the available
operations. Figure~\ref{fig:maqB} has a very basic example. The clause
$\mathit{MACHINE}$ has the name of module.  The next two clauses respectively
reference external modules and create an instance of an external module. The
$\mathit{VARIABLES}$ clauses declares the name of the variables that compose the
state of the machine. Next, the $\mathit{INVARIANT}$ clause defines the type and
other restrictions on the variables. The $\mathit{INITIALIZATION} $ specifies
the initial states. Finally, operations correspond to the transitions between
states of the machine.


\begin{figure}[h]
  % \begin{small}
  $$
  \begin{array}{lcl}
    \begin{array}[t]{l}
      \MACHINE \quad  \mathit{micro} \\
      \SEES \quad \mathit{TYPES}, \mathit{ALU} \\
      \INCLUDES  \quad \mathit{MEMORY} \\
      \VARIABLES \quad    \mathit{pc}  \\
      \INVARIANT\\ 
      \quad \mathit{pc} \in \mathit{INSTRUCTION} 
    \end{array}
    & \hspace*{0cm} &
    \begin{array}[t]{l}
      \INITIALISATION  \mathit{pc} := 0 \\
      \OPERATIONS\\
      \mathit{JMP} \mathit{( jump )} = \\
      \quad \PRE \mathit{jump} \in \mathit{INSTRUCTION}\\ 
      \quad \THEN \mathit{pc} := \mathit{jump}\\  
      \quad \END \\
      \END
    \end{array}
  \end{array}
  $$
\caption{A very basic B machine.}
\label{fig:maqB}
\end{figure}


\section{Model structure and basic components}
\label{sec:models}
%Em cada subsecaoo descrever os principais lemas que foram provados.
%Sugestheo de David:
% a) structure
% b) formalization of bit-level concepts
% c) formalization of bit vectors
% d) formalization of byte and word-level concepts
% e) formalization of integer ranges 

We have been developed a reusable set of basic definitions to model hardware concepts and data types
concepts. These definitions are grouped into three separate development projects
and are available as libraries. A fourth project is devoted to the higher-level aspects of the platform. Thus the workspace is
composed of: a power library\footnote{The power library has the basics definitions to help the theorems
prover about simple calculus of power, especially power of two. It has constants, that represents all
results of power function needed, and the definition of power function.}, a hardware library, a types
library and a project for the specific platform, in this case the Z80. The corresponding dependency
diagram is depicted in Figure~\ref{fig:hardware-definition-graph}; information specific to each project is
presented in the following.


\begin{figure}[h] \centering
\includegraphics[width=.92\textwidth]{diagramaEstrutural_vertical.png}
 \caption{Dependency diagram of the Z80 model.}
\label{fig:hardware-definition-graph}
\end{figure}



\subsection{Bit representation and manipulation}

The entities defined in the module $\mathit{BIT\_DEFINITION}$ are the
type for bits, logical operations on bits (negation, conjunction,
disjunction, exclusive disjunction), as well as a conversion function
from booleans to bits.

First, bits are modelled as a set of integers: $\mathit{BIT} =
\mathit{0..1}$. The negation is an unary function on bits and it is
defined as:

$
\begin{array}{l}
\mathit{bit\_not}  \in  \mathit{BIT}  \fun  \mathit{BIT}  \land \forall ( \mathit{bb}). (\mathit{bb} \in \mathit{BIT} \implies \mathit{bit\_not}(\mathit{bb}) =
1-\mathit{bb})\\
\end{array}
$

The module also provides lemmas on negation that may be useful for the
users of the library to develop proofs:

$
\begin{array}{l}
%  \mathit{bit\_not}(0) = 1;  \mathit{bit\_not}(1) = 0; \\
\forall (\mathit{bb}).(\mathit{bb} \in \mathit{BIT} \implies \mathit{bit\_not}(\mathit{bit\_not}(\mathit{bb})) = \mathit{bb})
\end{array}
$

Conjunction is an unary function on bits and it is defined as:

$
\begin{array}{l}
\mathit{bit\_and} \in \mathit{BIT} \times \mathit{BIT} \fun \mathit{BIT} \land \\
\forall (\mathit{b1}, \mathit{b2}).(\mathit{b1}  \in \mathit{BIT}  \land \mathit{b2} \in \mathit{BIT} \implies \\
\quad ((\mathit{bit\_and}(\mathit{b1}, \mathit{b2}) = 1) \iff (\mathit{b1} = 1)  \land  (\mathit{b2} = 1)))
\end{array}
$

The module provides the following lemmas for conjunction, either:

$
\begin{array}{l}
%  \mathit{bit\_and}(0,0) = 0;  \mathit{bit\_and}(0,1) = 0; \\
%  \mathit{bit\_and}(1,0) = 0;  \mathit{bit\_and}(1,1) = 1; \\
\forall (\mathit{b1},\mathit{b2}).(\mathit{b1} \in \mathit{BIT} \land \mathit{b2} \in \mathit{BIT} \implies \\
\quad (\mathit{bit\_and}(\mathit{b1}, \mathit{b2}) = \mathit{bit\_and}(\mathit{b2},\mathit{b1})))\land \\
\forall (\mathit{b1},\mathit{b2},\mathit{b3}).(\mathit{b1} \in \mathit{BIT} \land  \mathit{b2} \in \mathit{BIT} \land \mathit{b3} \in \mathit{BIT} \implies \\
\quad (\mathit{bit\_and}(\mathit{b1}, \mathit{bit\_and}(\mathit{b2},\mathit{b3})) = \mathit{bit\_and}(\mathit{bit\_and}(\mathit{b1},\mathit{b2}),\mathit{b3})))\\
% \forall (\mathit{b1}).(\mathit{b1} \in \mathit{BIT} \implies (\mathit{bit\_and}(\mathit{b1}, 1) = \mathit{b1})); \\
% \forall (\mathit{b1}).(\mathit{b1} \in \mathit{BIT} \implies (\mathit{bit\_and}(\mathit{b1}, 0) = 0));
\end{array}
$

The module provides definitions of $\mathit{bit\_or}$ (disjunction)
and $\mathit{bit\_xor}$ (exclusive disjunction), as well as lemmas on
those operators. These are standard and their expression in B is
similar as for $\mathit{bit\_and}$, they are thus omitted.

Finally, the conversion from booleans to bits is simply defined as:

$
\begin{array}{l}
\mathit{bool\_to\_bit} \in \BOOL \fun \mathit{BIT} \land \mathit{bool\_to\_bit} = \{ \TRUE \mapsto 1, \FALSE \mapsto 0 \} \\
\end{array}
$

Observe that all the lemmas that are provided in this module have been
mechanically proved by the theorem prover included with our B
development environment. None of these proofs requires human insight.


\subsection{Representation and manipulation of bit vectors}

Sequences are pre-defined in B, as functions whose the domain is an
integer range with lower bound 1 (one). Indices in bit vectors usually
range from 0 (zero) upwards and the model we propose obeys this
convention by making an one-position shift where necessary. This shift
is important to use the predefined functions of sequences. We thus
define bit vectors as non-empty sequences of bits, and
$\mathit{BIT\_VECTOR}$ is the set of all such sequences:
$\mathit{BIT\_VECTOR} = \seq1(\mathit{BIT})$.

The function $\mathit{bv\_size}$ returns the size of a given bit vector. It is basically a wrapper for the
predefined function $\mathbf{size}$ that applies to sequences.

$
\begin{array}{l}
\mathit{bv\_size} \in \mathit{BIT\_VECTOR} \fun \nat_1 \land \\
\mathit{bv\_size} = \lambda bv . (bv \in \mathit{BIT\_VECTOR} \mid \mathbf{size}(bv))
\end{array}
$

We also define two functions $\mathit{bv\_set}$ and $\mathit{bv\_clear}$ that, given a bit vector, and a
position of the bit vector, return the bit vector resulting from setting the corresponding position to 0
or to 1, and a function $\mathit{bv\_get}$ that, given a bit vector, and a valid position, each one
returns the value of the bit at that position. Only the first definition is shown here:


$
\begin{array}{l}
\mathit{bv\_set} \in \mathit{BIT\_VECTOR} \times \nat \fun \mathit{BIT\_VECTOR} \land \mathit{bv\_set} =\\
\lambda v, n . (v \in \mathit{BIT\_VECTOR} \land n \in \nat \land n <\mathit{bv\_size}(v)
\mid v \lover \{ n+1 \mapsto 1 \})
\end{array}
$


The function $bv\_catenate$ takes as parameters two bit vectors $v$ and $w$, and returns the result of the
concatenation of $v$ and $w$, such that $v$ constitutes the most significant part of the result.


% $
% \begin{array}{l}
% \mathit{bv\_catenate} \in \mathit{BIT\_VECTOR} \times \mathit{BIT\_VECTOR} \fun \mathit{BIT\_VECTOR} \land \\
% \mathit{bv\_catenate} = \lambda v, w \bullet (v \in \mathit{ BIT\_VECTOR} \land w \in \mathit{ BIT\_VECTOR}  \mid v 
% %\conc
%   w)
% \end{array}
% $

\hspace*{0.00in} \it bv\_catenate  $\in$  \it BIT\_VECTOR  $\times$  \it BIT\_VECTOR  $\fun$ \it
BIT\_VECTOR $\land$\\
\hspace*{0.00in} \it bv\_catenate \rm =  $\lambda$  v\rm ,\it w \rm . \rm (\it v 
$\in$  \it BIT\_VECTOR $\land$ \it w $\in$  \it BIT\_VECTOR  $\mid$  \it v\^ \it w\rm ) %$\cat$


We also define a function $\mathit{bv\_zero}$ that, given a positive
integer $n$, return a bit vector of size $n$, with all bits set to 0.
A similar function, called $\mathit{bv\_one}$, with all bits set to 1
is also defined but not presented here.

$
\begin{array}{l}
\mathit{bv\_zero} \in \nat_1 \fun \mathit{BIT\_VECTOR} \land \\
\mathit{bv\_zero} = \lambda n \bullet (n \in \nat_1 \mid 1..n \times \{0\}) 
\end{array}
$



Additionally, the module provides definitions for the classical
logical combinations of bit vectors: $\mathit{bit\_not}$,
$\mathit{bit\_and}$, $\mathit{bit\_or}$ and $\mathit{bit\_xor}$. Only
the first two are presented here. Observe that the domain of the
binary operators is restricted to pairs of bit vectors of the same
length:

$
\begin{array}{l}
\mathit{bv\_not} \in \mathit{BIT\_VECTOR} \fun \mathit{BIT\_VECTOR} \land \\
\mathit{bv\_not} = \lambda v . (v \in \mathit{BIT\_VECTOR} \mid \quad \lambda i . (1 .. \mathit{bv\_size}(v)) \mid \mathit{bit\_not}(v(i))) \land \\
\mathit{bv\_and} \in \mathit{BIT\_VECTOR} \times \mathit{BIT\_VECTOR} \fun \mathit{BIT\_VECTOR} \land \\
\mathit{bv\_and} = \lambda v_1, v_2 . (v_1 \in \mathit{BIT\_VECTOR} \land v_2 \in \mathit{BIT\_VECTOR} \land \\
\mathit{bv\_size}(v_1) = \mathit{bv\_size}(v_2) \mid \lambda i . (1 .. \mathit{bv\_size}(v_1)) \mid
\mathit{bit\_and}(v_1(i), v_2(i)))
\end{array}
$

We provide several lemmas on bit vector operations. These lemmas
express properties on the size of the result of the operations
as well as classical algebraic properties such as associativity
and commutativity.

\subsection{Modelling bytes and bit vectors of length 16}

Bit vectors of length 8 are bytes. They form a common entity in
hardware design. We provide the following definitions:


\hspace*{0.0in}\it BYTE\_WIDTH \rm = 8 $\land$ \it BYTE\_INDEX \rm = 1 $\upto$ \rm  BYTE\_WIDTH\rm $\land$

\hspace*{0.0in}\it PHYS\_BYTE\_INDEX \rm = \rm 0 $\upto$ \rm (\it BYTE\_WIDTH\rm -\rm 1\rm )\hspace*{0.10in} $\land$

\hspace*{0.0in}\it BYTE \rm = \rm \{ \it bt  $\mid$  \it bt $\in$ \it BIT\_VECTOR  $\land$  \it bv\_size\rm (\it bt\rm )\rm =\it BYTE\_WIDTH\rm \}\hspace*{0.10in} $\land$

\hspace*{0.0in}\it BYTE\_ZERO  $\in$  \it BYTE  $\land$ \it BYTE\_ZERO \rm = \it BYTE\_INDEX  $\times$  \rm \{\rm 0\rm \}

The $\mathit{BYTE\_INDEX}$ is the domain of the functions modelling bytes. It starts at 1 to obey a
definition of sequences from B. However, it is common in hardware architectures to start indexing from
zero. The definition $\mathit{PHYS\_BYTE\_INDEX}$ is used to provide functionalities obeying this
convention. The $\mathit{BYTE}$ type is a specialized type from $\mathit{BIT\_VECTOR}$, but it has a size
limit. Other specific definitions are provided to facilitate further modelling: the type $\mathit{BV16}$
is created for bit vector of length 16 in a similar way.



\subsection{Bit vector arithmetics}

Bit vectors are used to represent and combine numbers: integer ranges (signed or unsigned). Therefore, our
library includes functions to manipulate such data, for example, the function $\mathit{bv\_to\_nat}$ that
maps bit vectors to natural numbers:



$
\begin{array}{l}
\mathit{bv\_to\_nat} \in \mathit{BIT\_VECTOR} \fun \nat \land \\
\mathit{bv\_to\_nat} = \lambda v . (v \in \mathit{BIT\_VECTOR} \mid \sum i . (i \in \dom(v) . v(i)
\times 2^{i-1}))
\end{array}
$

An  associated lemma is: $\forall n . (n \in \nat_1 \implies \mathit{bv\_to\_nat}(\mathit{nat\_to\_bv}(n)) = n)$

\subsection{Basics data types}

The instruction set of microcontrollers usually have common data types. These types are placed in the
types library. Each type module has functions to manipulate and convert its data. There are six common
basics data types represented by modules, see details in table~\ref{tab:types}.


\begin{table}
\caption{Descriptions of basic data types}
\label{tab:types}

% \begin{center}
% \begin{tabular}{|c|c|c|c|c|c|c|}
% \hline
%  $Type\ Name$ & UCHAR & SCHAR & USHORTINT & SSHORTINT  & BYTE & BV16 \\\hline
%  $Range$ & 0..255 & -128..127 & 0..65.535  & -32.768..32.767  & -- & --\\ \hline
%  $Physical\ Size $ & 1 byte & 1 byte & 2 bytes & 2 bytes &  1 bytes & 2 bytes \\ \hline
% \end{tabular}
% \end{center}

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
 $Type\ Name$ & $Range$ & $Physical\ Size $\\\hline
 UCHAR & 0..255 & 1 byte\\\hline
 SCHAR & -128..127 & 1 byte  \\\hline
 USHORTINT & 0..65.535 & 2 byte \\\hline
 SSHORTINT & -32.768..32.767 & 2 byte \\\hline
 BYTE & -- & 1 bytes  \\\hline
 BV16 & -- & 2 bytes \\ \hline
\end{tabular}
\end{center}


\end{table}




Usually, each type module just needs to instantiate concepts that were already defined in the hardware
modelling library.  For example, the function $\mathit{bv\_to\_nat}$ from bit vector arithmetics is
specialized to $\mathit{byte\_uchar}$. As the set $\mathit{BYTE}$ is a subset of the
$\mathit{BIT\_VECTOR}$, this function can defined as follows:


$
\begin{array}{l}
\mathit{byte\_uchar} \in \mathit{BYTE} \fun \nat \land \\
\mathit{byte\_uchar} = \lambda (v) . ( v \in BYTE | bv\_to\_nat(v) )
\end{array}
$

The definitions of the library types reuse the basic definitions from the hardware library. This provides
greater confidence and facilitates the proof process, because the prover can reuse the previously defined
lemma.


The inverse function $\mathit{uchar\_byte}$ is easily defined:

$
\begin{array}{l}
\mathit{uchar\_byte} \in \mathit{UCHAR}  \fun  \mathit{BYTE}  \land \\
   \mathit{uchar\_byte} = \ (\mathit{byte\_uchar}) ^{-1}
\end{array}
$

% We also created the following lemmas:
%
% $
% \begin{array}{l}
%  \forall (val) . (val \in \mathit{UCHAR} |
%  \mathit{byte\_uchar}(\mathit{uchar\_byte}(val)) = val) \land\\
%  \forall (by) . (by \in \mathit{BYTE} |
%  \mathit{uchar\_byte}(\mathit{byte\_uchar}(by)) = by)
% \end{array}
% $
%[NEW PARAGRAPH-TO-REVIEW]
%Similarly, several other general functions and lemmas were created for all other data types.
%Some times, we need create arithmetic and logic functions that are more specific for a
%determined computer architecture. These functions are developed in the module ALU 
%(arithmetic  logic unit). The following shows some examples of specific functions used in
%microcontroller model of Z80. For example, the function $\mathit{instruction_next}$
%receives a $\mathit{BYTE}$ and returns a $\mathit{BYTE}$ that contains a sequence of bit:
%a signal bit, 



\section{A B model of the Z80 instruction set}
\label{sec:z80}

The \textit{Z80} is a CISC microcontroller developed by \textit{Zilog}~\cite{Z80_manual}. It supports 158
different instructions, including all the 78 from Intel 8080 microprocessor, and all of them were
specified. These instructions are classified into these categories: load and exchange; block transfer and
search; arithmetic and logical; rotate and shift; bit manipulation; jump, call and return; input/output;
and basic cpu control. Each category of instruction has different elements of
specification.



This section shows the elements that make up the different types of instructions.
The main elements are specified in the microcontroller module Z80 and parts of it
are presented in this section~\ref{sec:z80}. Groups of registers are represented
by the variables of the specification states that appear in clause
\textit{VARIABLES}. The declaration of valid states of variables in the clause is
in the \textit{INVARIANT} clause and the initial state is defined in the
\textit{INITIALISATION} clause. The assembly instructions are defined by the
clause \textit{OPERATIONS}, and the most of its specification constructions are
similar to constructions from traditional programming languages. Several
functions were created to Z80. General functions that can be used in others
microcontroller models are defined in the modules of data types. Specific
functions of the microcontroller are defined in the ULA (arithmetic logic unit).



The main module includes an instance of the memory module and accesses the definitions from basic data
types modules and the \textit{ALU} module.


\begin{sloppypar}

\bf MACHINE

\hspace*{0.15in}\it Z80

\bf INCLUDES

\hspace*{0.10in}\it MEMORY

\bf SEES

\hspace*{0.10in}\it ALU, \it BIT\_DEFINITION, \it BIT\_VECTOR\_DEFINITION,

\hspace*{0.10in}\it BYTE\_DEFINITION, \it BV16\_DEFINITION,

\hspace*{0.10in}\it UCHAR\_DEFINITION, \it SCHAR\_DEFINITION,

\hspace*{0.10in}\it SSHORT\_DEFINITION ,\it USHORT\_DEFINITION
\end{sloppypar}


\subsection{Modelling registers and input and output ports} [TODO:I need review
the english]

The Z80 CPU includes alternative set of accumulator, flag and general registers. The CPU contains a stack
pointer ($\mathit{sp}$), program counter ($\mathit{pc}$), two index registers ($\mathit{ix}$ and $\mathit{iy}$), an
interrupt register ($\mathit{i\_}$), a refresh register ($\mathit{r\_}$), two bits ($\mathit{iff1}$,
$\mathit{iff2}$) used to control the interruptions, a pair of bits to define the interruption mode ($\mathit{im}$)
and the input and output ports ($\mathit{i\_o\_ports}$). Below, its definitions are represented by
\textit{INVARIANT}.
  
\begin{sloppypar}
\bf INVARIANT

\hspace*{0.10in}\it rgs8  $\in$  \it id\_reg\_8  $\fun$  \it BYTE  $\land$ 

\hspace*{0.10in}\it pc  $\in$  \it INSTRUCTION  $\land$  \it sp  $\in$  \it BV16  $\land$  \it ix  $\in$  \it BV16  $\land$  \it iy  $\in$  \it BV16  $\land$ 

\hspace*{0.10in}\it i\_  $\in$  \it BYTE  $\land$  \it r\_ $\in$  \it BYTE  $\land$  

\hspace*{0.10in}\it iff1  $\in$  \it BIT  $\land$ \hspace*{0.10in}\it iff2  $\in$  \it BIT  $\land$ 

\hspace*{0.10in}\it im $\in$ (\it BIT $\times$ \it BIT\rm )  $\land$ 

\hspace*{0.10in}\it i\_o\_ports  $\in$  \it BYTE  $\fun$  \it BYTE
\end{sloppypar}

% 

% Features of microcontroller
 The internal registers contain 176 bits of reading/writing memory that are represented by
identifiers used as parameters in the instructions . It includes two sets of six general purpose
registers which may be used individually as 8-bits registers or as 16-bits register pairs.  The working registers
are represented by variable $\mathit{rgs8}$. The domain of $\mathit{rgs8}$ ($\mathit{id\_regs8}$) is a set
formed by identifiers of registers of 8 bits. These registers can be accessed in pairs, forming 16-bits,
resulting in another set of identifiers of 16-bits registers, named $\mathit{id\_reg16}$.

\begin{sloppypar}
\bf SETS

\hspace*{0.10in}\it id\_reg\_8 \rm = \rm \{ \it a0 \rm , \it f0 \rm , \it f\_0 \rm , \it a\_0 \rm ,

\hspace*{1.0 in}\it b0 \rm , \it c0 \rm , \it b\_0 \rm , \it c\_0 \rm ,

\hspace*{1.00in}\it d0 \rm , \it e0 \rm , \it d\_0 \rm , \it e\_0 \rm ,

\hspace*{1.0in}\it h0 \rm , \it l0 \rm , \it h\_0 \rm , \it l\_0 \} ;

\hspace*{0.10in}\it id\_reg\_16 \rm = \rm \{ \it BC \rm , \it DE \rm , \it HL \rm , \it SP \rm , \it AF \rm \}
\end{sloppypar}

The main working register of Z80 is the accumulator ($\mathit{rgs8(a0)}$) used for arithmetic/logic,
input/output and loading/storing operations.

\subsection{Flag register} [TODO:I need review the text]
Another important element is the ``z'' register ($\mathit{rgs8(z0)}$),  that is used as a flag register. This
register uses only six bits to represent the execution result status of each instruction.
According to the official manual the bits 3 and 5 are not used and the others bits have the follow meaning:
\begin{description}
  \item[$\mathit{bv\_get(rgs8(z0),0)}$] - The Carry bit
  \item[$\mathit{bv\_get(rgs8(z0),1)}$] - The Add/Subtract bit
  \item[$\mathit{bv\_get(rgs8(z0),2)}$] - The Parity or Overflow bit
  \item[$\mathit{bv\_get(rgs8(z0),4)}$] - The Half Carry bit
  \item[$\mathit{bv\_get(rgs8(z0),6)}$] - The Zero bit
  \item[$\mathit{bv\_get(rgs8(z0),7)}$] - The Sign bit 
\end{description}

These bits also can be used to specify security properties for microcontroller programs.   

\textbf{Assuring the absence of overflow:}
 \emph{To assure that not to happen overflow, the developer can add this
 expression ($\mathit{bv\_get(rgs8(z0),0)} \neq 1 \land \mathit{bv\_get(rgs8(z0),2) \neq 1}$)
 in the invariant. By default, the overflow can happen, but many times it can be dangerous. 
 Then, the developer may prohibit its use. This restriction can also become the more difficult
 to specify.}



\subsection{Manipulation data functions from Z80}
[I need to review the text]\\ There are some specific functions
from Z80 to manipulate the data. In addressing mode, the function $\mathit{bv\_ireg\_plus\_d}$ is  used to indexed address. It receives the
value of register ($\mathit{ix}$ or $\mathit{iy}$) and the displacement to return the sum, the result is the dislocated address memory, see
its the definition.

\hspace*{0.0in}\it bv\_ireg\_plus\_d \rm : \rm(\it BV16  $\times$  \it SCHAR  $\fun$  \it BV16\rm )  $\land$ 

\hspace*{0.0in}\it bv\_ireg\_plus\_d \rm =  $\lambda$  \rm ( \it ix\_iy \rm , \it disloc \rm ) \rm . \rm ( \it ix\_iy  $\in$  \it BV16  $\land$  \it disloc  $\in$  \it SCHAR   

\hspace*{0.20in}$\mid$ \it ushort\_bv16 \rm ( \rm (\it bv16\_ushort \rm ( \it ix\_iy \rm ) \rm + \it disloc \rm ) 
$\mod$ \rm 6\rm 5\rm 5\rm 3\rm 6 \rm ) \rm )

Another derived function is  $\mathit{bv\_(ireg\_plus\_d)}$, this returns the value in the memory  address
returned by $\mathit{bv\_ireg\_plus\_d}$ function and its definition is similar.

There is a specific function to refresh the flag register, it is named $\mathit{update\_reg\_flag}$. It is typed of
follow mode: \it update\_flag\_reg \rm $\in$ \rm (\it BIT  $\times$  \it BIT  $\times$  \it BIT  $\times$  \it
BIT $\times$  \it BIT  $\times$  \it BIT\rm) $\fun$  \rm (\rm \{\it f0\rm \}  $\times$  \it BYTE\rm ). 

\it update\_flag\_reg \rm =  $\lambda$  \rm (\it s7 \rm, \it z6 \rm,\it h4 \rm,\it pv2 \rm ,\it n1
\rm ,\it c0 \rm)$\bullet$

\rm ( \it s7 $\in$ \it BIT $\land$ \it z6 $\in$ \it BIT $\land$ \it h4 $\in$ \it
BIT $\land$ \it pv2 $\in$ \it BIT $\land$ \it n1 $\in$ \it BIT $\land$ \it c0 $\in$ \it BIT
  
\hspace*{0.20in}\rm $\mid$( \it f0  $\mapsto$  \rm \rm [\it c0\rm , \it n1\rm , \it pv2\rm , \rm 1\rm , \it
h4\rm , \rm 1\rm , \it z6\rm , \it s7\rm \rm ]\rm ) \rm )


\subsection{Program, stack and data memory}[I need review the text]

The Z80 uses a unique memory for storing program instructions, data stack and data work. The memory has 16-bits
addressing and each address represents a byte. Thus the data from the memory module is very simple, as shown below,
but an additional care must be taken to preserve the consistency of memory.

\begin{sloppypar}
\bf INVARIANT \\
\hspace*{0.10in}\it mem  $\in$  \it BV16  $\fun$  \it BYTE 

\end{sloppypar}
  
In general, the instructions can access all memory address, but it is very dangerous. For add more security, is
important that the program instructions has the access limited by region. Thus the designer can specify address
regions to restrict the access from instructions. The address regions can be specified how shown below.
The constants ($\mathit{PRORGRAM\_R\_ADR,DATA\_R\_ADR,STACK\_R\_ADR}$) defines respectively a range of restricted address
for: programs instructions, data work, data stack. 

$
\begin{array}{l}
\mathit{PROGRAM\_R\_ADR} = 0..16384 \land\\
\mathit{DATA\_R\_ADR} = 16385..49151 \land\\
\mathit{STACK\_R\_ADR} = 49152..65535
\end{array}
$

\textbf{Assuring the absence of overlapping of address regions:}
 \emph{To assure that address regions are well defined, then the designer must to verify the below expression.}

\begin{sloppypar}
\hspace*{0.10in}\it PROGRAM\_R\_ADR $\cap$ DATA\_R\_ADR $\cap$  STACK\_R\_ADR $=$ \{\}
\end{sloppypar}
 
\textbf{Preserving the consistency of the memory:} \emph{In general, the access to
some address regions is dangerous. Then, in each instruction has a specific pre-condition that verify
if the new address memory, that will be updated, is member of its region. For example, the $\mathit{PUSH}$
program instruction allows write only in the region of stack ($\mathit{STACK\_R\_ADR}$).}



\subsection{Arithmetic logic unit}
 
There are many functions defined in the module \textit{ALU}. In general, these functions take basic definitions or functions
to build new more specific functions. The function $\mathit{half8UCHAR}$ is used to get the half part of $\mathit{UCHAR}$ value.
It is important to know the half carry and it is used in the function $\mathit{add8UCHAR}$. 

\hspace*{0.0in}

\hspace*{0.0in}\it half8UCHAR  $\in$  \it UCHAR  $\fun$  \it UCHAR  $\land$ 

\hspace*{0.0in}\it half8UCHAR \rm =  $\lambda$  \rm (\it ww\rm )\rm .\rm (\it ww  $\in$  \it UCHAR  $\mid$  \it ww  $\mod$  \it $2^{4}$\rm )

\hspace*{0.0in}

 
The function $\mathit{add8UCHAR}$ receive a bit carry and two $\mathit{UCHAR}$ values and return respectively the 
sum, the sign bit, the carry bit, the half carry bit and the zero bit. It is typed how follow: \it add8UCHAR \rm :
\rm (\it BIT $\times$ \it UCHAR $\times$ \it UCHAR\rm ) $\fun$ \rm (\it UCHAR $\times$  \it BIT  $\times$  \it BIT  $\times$  \it BIT  $\times$  \it BIT\rm ) and its definitions is:

\hspace*{0.0in}\it add8UCHAR\rm = $\lambda$ \rm(\it carry\rm,\it w1\rm \it w2\rm)\rm.\rm

\hspace*{0.0in}(\it carry $\in$  \it BIT  $\land$  \it w1  $\in$  \it UCHAR  $\land$  \it w2  $\in$  \it UCHAR
$\mid$

\hspace*{0.40in}\rm(\rm(\rm(\it carry \rm + \it w1 \rm + \it w2 \rm )  $\mod$  \it $2^{8}$ \rm ),

\hspace*{0.40in}\it bool\_bit\rm ( \it carry \rm + \it uchar\_schar\rm (\it w1\rm ) \rm + \it uchar\_schar \rm (\it
w2\rm ) $<$ \rm 0\rm ),

\hspace*{0.40in}\it bool\_bit\rm ( \it carry \rm + \it w1 \rm + \it w2 $>$ \it UCHAR\_MAX\rm )\rm ,

\hspace*{0.40in}\it bool\_bit\rm ( \it carry \rm + \it half8UCHAR\rm (\it w1\rm ) \rm + \it half8UCHAR\rm ( \it
w2\rm )  $\geq$  \it $2^{4}$\rm )\rm,

\hspace*{0.40in}\it bool\_bit\rm ( \rm ( \rm (\it carry \rm + \it w1 \rm + \it w2 \rm )  $\mod$  \it $2^{8}$ \rm
)\rm = \rm 0\rm )\rm )\hspace*{0.10in}\rm )

\hspace*{0.20in}

A related function to subtract operation is $\mathit{substract8UCHAR}$. There are the same functions for the
$\mathit{SCHAR}$ type, they are respectively $\mathit{add8SCHAR}$ and $\mathit{substract8SCHAR}$, all these
functions are of 8 bits ($\mathit{BYTE}$) and defined similarly. In the same way, the arithmetic functions for 16
bits ($\mathit{BV16}$) are defined.
The module ALU has several others functions, but only some simplest functions also are typed and explained below:

\begin{itemize}
  %\item \it inc  $\in$ \it BYTE $\fun$  \it BYTE \rm - It receives a byte and
  %returns its increment. There is a similar function named $\mathit{dec}$.

  \item \it instruction\_next  $\in$  USHORT  $\fun$  USHORT \rm - It receives the  
  actual value from program counter register (\textit{pc}) and returns its increment.
 \item \it is\_negative  $\in$  \it BYTE  $\fun$  \it BIT \rm - It returns the most significant bit,
 in others words, the signal bit.

  
 % \item \it is\_zero  $\in$  \it BYTE  $\fun$  \it BIT \rm - It returns 1 if the received
 % byte is zero, otherwise returns 0.

  %\item \it update\_refresh\_reg \rm - It receives a byte and returns its increment until the seventh bit.

\end{itemize}

Every logic functions that are defined in the \textit{BYTE} and \textit{BV16} module are included in the \textit{ALU}
module. Then, these functions can be seen directly in the \textit{ALU} and \textit{Z80} module.

\subsection{Modelling the instructions}[I need review the text]

Each instruction is represented by a B operation in the module Z80. The main module (\textit{Z80}) has two
types of operations, a type represents the external actions and the other represents the instructions of
microcontrollers. The external actions are shown in the section ~\ref{sec:externalactions}.  A simple
example from instruction is a $\mathit{LD\_(nn)\_A}$\footnoteremember{myfootnote}{The tools B does not allow use parentheses in identifiers,
then the characters \{``('',``)''\} are replaced respectively by \{``9'',``0''\} in the real specification.} shown below.
Many times to model a instruction is necessary to use the pre-defined functions, this facilitates the construction of model. By default, all
parameters from operations are either predefined elements in the model or integers values in the decimal
representation. This instruction use the $\mathit{updateAddressMem}$ function from \textit{Memory} module
and it receives a address memory and its new memory value. After, it increments the program counter
($\mathit{pc}$) and update the refresh register ($\mathit{r\_}$).


\hspace*{0.00in}\bf LD\_9nn0\_A \rm ( \it nn \rm ) \rm =

\hspace*{0.20in}\bf PRE \it nn $\in$ \it USHORT\hspace*{0.15in} $\land$ \hspace*{0.10in}\it nn\hspace*{0.10in} $\in$  \it DATA\_R\_ADR

\hspace*{0.20in}\bf THEN

\hspace*{0.20in}\bf updateAddressMem \rm ( \it ushort\_bv16 \rm ( \it nn \rm ) \rm , \it rgs8 \rm ( \it a0 \rm )
\rm )  $\para$

\hspace*{0.20in}\it pc \rm := \it instruction\_next \rm ( \it pc \rm )  $\para$  \it r\_ \rm := \it update\_refresh\_reg\rm (\it r\_\rm )

\hspace*{0.00in}\bf END\rm ;

The other instructions have a similar structure.

\subsection{Modeling the input/output instructions}

The Z80 has an extensive set of input and output (I/O) instruction and 256 ports for
devices. This model can transfer data blocks and between the I/O devices and any
of the internal registers or memory address.

The $\mathit{IN\_r(C)}$\footnoterecall{myfootnote} instruction is represented
by the follow B operation. It is from I/O group, then it receives a identifier of register
$\mathit{r}$ and, in this place, it stores the value of $\mathit{C}$ port address. Besides, it increments the
program counter and updates the flag registers.

\hspace*{0.0in}\bf IN\_r\_9C0 \rm ( \it rr \rm ) \rm =

\hspace*{0.0in}\bf PRE \it rr  $\in$  \it id\_reg\_8  $\land$  \it rr  $\not =$  \it f0\hspace*{0.15in}\bf THEN

\hspace*{0.20in}\bf ANY

\hspace*{0.40in}\it negative \rm , \it zero \rm , \it half\_carry \rm , \it pv \rm , \it add\_sub \rm , \it carry

\hspace*{0.20in}\bf WHERE 

\hspace*{0.40in}\it negative $\in$ \it BIT $\land$ \it zero $\in$ \it BIT $\land$ \it half\_carry $\in$ \it BIT 
$\land$ \it pv $\in$ \it BIT $\land$

 \hspace*{0.40in}\it add\_sub $\in$ \it BIT $\land$ \it carry $\in$ \it BIT  $\land$

\hspace*{0.40in}\it negative \rm = \it is\_negative \rm ( \it io\_ports \rm ( \it rgs8 \rm ( \it c0 \rm ) \rm ) \rm )  $\land$ 

\hspace*{0.40in}\it zero \rm = \it is\_zero \rm ( \it io\_ports \rm ( \it rgs8 \rm ( \it c0 \rm ) \rm ) \rm )  $\land$ 

\hspace*{0.40in}\it half\_carry \rm = \rm 0  $\land$ 

\hspace*{0.40in}\it pv \rm = \it parity\_even \rm ( \it io\_ports \rm ( \it rgs8 \rm ( \it c0 \rm ) \rm ) \rm ) $\land$

\hspace*{0.40in}\it add\_sub \rm =\hspace*{0.10in}\rm 0  $\land$ 

\hspace*{0.40in}\it carry \rm = \it z\_c

\hspace*{0.20in}\bf THEN

\hspace*{0.40in}\it rgs8 \rm := \it rgs8  $\lover$  \rm \{ \rm ( \it rr  $\mapsto$  \it io\_ports \rm ( \it rgs8 \rm ( \it c0 \rm ) \rm ) \rm ) \rm ,

\hspace*{0.40in}\it update\_flag\_reg\rm (\it negative\rm,\it zero\rm,\it half\_carry\rm,\it pv\rm,\it add\_sub\rm,\it carry)\rm\}$\para$

\hspace*{0.40in}\it pc \rm := \it instruction\_next \rm ( \it pc \rm )  $\para$  \it r\_ \rm := \it update\_refresh\_reg\rm (\it r\_\rm )

\hspace*{0.0in}\bf END \rm

The main I/O instructions work similarly, for example: $\mathit{OUT(n),A}$  or
$\mathit{OUT (C ), r}$. There are several others instructions of I/O, besides these are
the most commonly used.

% $
% \begin{array}{l} 
% \mathit{IN\_r\_9C0} ( rr ) = \\
% \quad   \PRE rr \in id\_reg\_8    \THEN\\
% \quad\quad \ANY data\_in, negative , zero , half\_carry , pv , add\_sub , carry\\ 
% \quad\quad \WHERE data\_in \in \mathit{BYTE} \land negative \in \mathit{BIT}\land\\
% \quad\quad\quad carry \in \mathit{BIT} \land half\_carry \in \mathit{BIT} \land zero \in \mathit{BIT} \land \\
% \quad\quad\quad negative = is\_negative (data\_in) \land zero = is\_zero(data\_in ) \land\\
% \quad\quad\quad half\_carry = 0 \land pv =parity\_even\_BYTE ( data\_in )    \land\\
% \quad\quad\quad add\_sub =  0 \land carry = z\_c \\
% \quad\quad  \THEN \\
% \quad\quad\quad i\_o\_ports ( rgs8 ( c0 ) ) := data\_in ||\\
% \quad\quad\quad rgs8 := rgs8 <+ \{ ( rr |-> data\_in ) ,\\
% \quad\quad\quad get\_new\_flag\_register\_SZ\_H\_PvNC ( rgs8 , negative , zero, half\_carry , pv , add\_sub , carry ) \} ||\\
% \quad\quad\quad pc := instruction\_next( pc )\\
% \quad\quad \END\\
% \quad \END\\
% \end{array}
% $




\subsection{Modeling the external actions}
\label{sec:externalactions}

The external actions change the state of microcontroller and they are not
instructions, for example, the refreshing of I/O port and the interruptions
request. The external actions are also model by operations and they are named with the
prefix ``$ext\_$'' and after the name of action. There are just four external
actions: $ext\_update\_io\_ports$, $ext\_NMI$ and $ext\_INT$, $ext\_Reset$. The
$ext\_update\_io\_ports$ just change the state of I/O port, see.

\hspace*{0.20in}\bf ext\_update\_io\_ports\rm (\it address\rm ,\it value\rm )\rm =

\hspace*{0.20in}\bf PRE \it address  $\in$  \it UCHAR  $\land$ \hspace*{0.10in}\it value  $\in$  \it SCHAR \bf THEN

\hspace*{0.40in}\it io\_ports \rm ( \it uchar\_byte \rm ( \it address \rm ) \rm ) \rm := \it schar\_byte \rm ( \it
value \rm )

\hspace*{0.20in}\bf END\rm 

The others external actions are related to interrupts. The interrupts allows that the devices suspend a routine from CPU and start
another service routine. This service routine can exchange data or signals between CPU and external devices. When a
routine is finished, then the CPU come back to the last routine that was interrupted.

For the interrupts, the following things are important:  the interrupt flip-flops ($\mathit{iff1}$ and
$\mathit{iff2}$), the types of interrupts (maskable and non-maskable), the interrupt mode (set with the $\mathit{IM
0}$, $\mathit{IM 1}$, $\mathit{IM 2}$ instructions) and the $\mathit{i\_}$ register.

The $\mathit{iff1}$ and $\mathit{iff2}$ control the maskable interrupts ($\mathit{INT}$). When the $\mathit{iff1}$
is set, the interrupt is enable, otherwise it is disable. The $\mathit{iff2}$ is used only as a tempory storage
place for $\mathit{iff1}$. The $\mathit{iff1}$ is 1 or 0 by instructions $\mathit{EI}$ and $\mathit{DI}$, that respectively
enable and disable the maskable interruptions.  


The interruptions and the \textit{reset} action change the state of
microcontroller. Theses actions are modeled by B operations and the its main
effects are shown below\footnote{Some definitions of constants: $\mathit{sp\_minus\_two}$ is the value of stack pointer minus 2,
%=$\mathit{dec\_BV16(dec\_BV16(sp))}$
 $\mathit{sp\_minus\_one}$ is the value of stack pointer minus 1,
%=$\mathit{dec\_BV16(sp)}$
$\mathit{pc\_high}$ is the most significant 8 bits and
$\mathit{pc\_low}$ is the others least significant.}.


 \textbf{NMI} - Non-maskable interrupts - The non-maskable cannot be disable
 by the programmer. Then, when a device makes a request, the $sp$ is pushed, the $pc$ receive
 $66H$ (102 in decimal), the $\mathit{iff1}$ is reset , $\mathit{iff2}$ stores
 $\mathit{iff1}$ and refresh register is updated.
  
\begin{sloppypar}
\bf updateStack\rm (\rm \{ \rm (\it sp\_minus\_two  $\mapsto$  \it pc\_low\rm )\rm ,\rm (\it sp\_minus\_one  $\mapsto$ \it pc\_high \rm ) \rm \}\rm )$\para$

\it sp \rm := \it sp\_minus\_two  $\para$ \it pc \rm := \rm 1\rm 0\rm 2 $\para$ \it iff1\rm :=\rm 0  $\para$  \it iff2\rm := \it iff1 $\para$

\it r\_ \rm := \it update\_refresh\_reg\rm (\it r\_\rm )\\
\end{sloppypar}

  \textbf{INT} - Maskable Interrupt -  This is usually reserved to important functions that can be enabled and
  disabled by the programmer. When a maskable interrupt action happens, both $\mathit{iff1}$ and $\mathit{iff2}$ are
  cleared, disabling the interrupts, the $sp$ is pushed, the refresh register is updated  and the other effects
  depend on the interrupt mode.
 

 \begin{itemize}
   
  \item The mode 0 is compatible with 8080 and  \it im \rm = \rm ( \rm 0 $\mapsto$  \rm 0 \rm ). When a 
  non-maskable interruption happen , the CPU fetches an instruction of one byte from an external device, usually an
  RST instruction, and the CPU executes it. The instruction code is received from a external device by data bus and
  it is represented by integer parameter called $\mathit{byte\_bus}$ .

 
  \item The mode 1 is the easiest and \it im \rm = \rm ( \rm 0  $\mapsto$  \rm 1 \rm ). Simply, when a non-maskable
  interruption happens, the program counter receives $38H$ (56 in decimal).
  
  \item The mode 2 is the most flexible and  \it im \rm = \rm ( \rm 1  $\mapsto$ \rm 1 \rm ). When a non-maskable
  interruption happens, an indirect call can be made to any address memory. The program counter receives a bit vector of size 16 composed in the
  part most significant the $\mathit{i\_}$ register and, in the  part least significant, the $\mathit{byte\_bus}$
  with the last bit reset.
 \end{itemize}

The essential part of maskable interrupt is shown below\footnote{ The
 $\mathit{byte\_bus}$ is parameter from  $\mathit{INT}$ operation }. 
 


\begin{sloppypar}

\hspace*{0.00in}\bf IF \it im \rm = \rm ( \rm 0  $\mapsto$  \rm 0 \rm ) \bf THEN  

\hspace*{0.10in}\bf IF\hspace*{0.10in}\it byte\_bus \rm $\in$  \it opcodes\_RST\_instruction

\hspace*{0.10in}\bf THEN\hspace*{1.05in}

\hspace*{0.40in}\it pc \rm := \it byte\_bus \rm - \rm 1\rm 9\rm
9\hspace*{0.10in} $\para$

\hspace*{0.40in}\bf updateStack\rm ( \rm \{ \it stack\rm ( \it
sp\_minus\_one\rm )  $\mapsto$  \it pc\_low\rm ,

\hspace*{0.40in}\it stack\rm (\it sp\_minus\_two\rm )  $\mapsto$  \it pc\_high
\rm \} \rm )  $\para$

\hspace*{0.40in}\it sp \rm := \it sp\_minus\_two  $\para$ \hspace*{0.10in}\it
r\_ \rm := \it update\_refresh\_reg\rm (\it r\_\rm )

\hspace*{0.10in}\bf ELSIF \it byte\_bus \rm = \it opcode\_\ldots\_instruction

\hspace*{0.40in}\bf \ldots 

\hspace*{0.10in}\bf END

\hspace*{0.00in}\bf ELSIF\hspace*{0.10in}\it im \rm =\hspace*{0.10in}\rm ( \rm
0  $\mapsto$  \rm 1 \rm ) \bf THEN

\hspace*{0.10in}\it pc \rm :=\hspace*{0.10in}\rm 5\rm 6  \hspace*{0.80in}
$\para$

\hspace*{0.10in}\bf updateStack\rm ( \rm \{ \it stack\rm (\it
sp\_minus\_one\rm )  $\mapsto$  \it pc\_low\rm ,

\hspace*{0.10in}\it stack\rm (\it sp\_minus\_two\rm )  $\mapsto$  \it pc\_high
\rm \} \rm )  $\para$

\hspace*{0.10in}\it sp \rm := \it sp\_minus\_two  $\para$ \hspace*{0.10in}\it
r\_ \rm := \it update\_refresh\_reg\rm (\it r\_\rm )\hspace*{0.85in}

\hspace*{0.00in}\bf ELSIF\hspace*{0.10in}\it im \rm = \rm ( \rm 1  $\mapsto$ 
\rm 1 \rm ) \bf THEN  \hspace*{0.70in}

\hspace*{0.10in}\it pc \rm := \it bv16\_ushort\rm (\it byte\_bv16\rm ( \it i\_
\rm ,\it bv\_clear\rm (\it rotateleft\rm (\it uchar\_byte\rm (\it byte\_bus\rm )\rm )\rm ,\rm 0\rm )\rm )\rm )$\para$

\hspace*{0.10in}\bf updateStack\rm ( \rm \{ \it stack\rm ( \it
sp\_minus\_one\rm )  $\mapsto$  \it pc\_low\rm ,

\hspace*{0.10in}\it stack\rm (\it sp\_minus\_two\rm )  $\mapsto$  \it pc\_high
\rm \} \rm )  $\para$

\hspace*{0.10in}\it sp \rm := \it sp\_minus\_two  $\para$ \hspace*{0.10in}\it
r\_ \rm := \it update\_refresh\_reg\rm (\it r\_\rm )

\hspace*{0.00in}\bf END\hspace*{0.10in}\\
\end{sloppypar}


\textbf{RESET}  - This just reset the registers related to the interruptions.

\begin{sloppypar}
\it iff1 \rm :=\rm 0 $\para$ \it iff2\rm :=\rm 0 $\para$  \it  im\rm := \rm (\rm 0 $\mapsto$ \rm 0\rm )  $\para$ 
\it pc\rm :=\rm 0 $\para$ \it i\_ \rm := [0,0,0,0,0,0,0,0] $\para$

\it rgs8 \rm := \it rgs8  $\lover$  \rm \{ \rm (\it a0  $\mapsto$ \rm [0,0,0,0,0,0,0,0] , \rm (\it
f0 $\mapsto$ \rm [0,0,0,0,0,0,0,0] \rm \} $\para$

\it r\_  \rm := [0,0,0,0,0,0,0,0] $\para$ \it sp \rm := [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
\end{sloppypar}


%The microcontroller model can specify security properties. For example, the
%last operation could have a restriction to write only in a defined region of memory.


\subsection{Conclusions about the Z80 model}



The Z80 formal model provides many benefits, because the verification of generated proof obligations assure: 
the use correct of data types, the developed security properties  and if the expressions used is well-defined(WD)\footnote{An expression
is called ``well-defined'' (or unambiguous) if its definition assigns it a unique interpretation or value.}. Furthermore, the designer has
a big flexibility to create news and specifics security properties, this is very useful to adjust the verification in accordance with the requirements.
Besides, this example of model could replace or improve the documentation used for users and assembly programmers. Z80 model is also useful to
develop verified software  until the assembly level. There are too much benefits when a formal model is developed, 
but verify completely the model is not an easy task and more details are shown in section\ref{sec:Verification}. 
Finally, the next section explain a developed study case and verified since first abstract B model until B assembly model.   

\section{Building and verifying assembly-level refinements}
\label{sec:studycase}


This section shows a case study that realizes a experimental evaluation of
a pilot project with B refinements until the assembly level. The object of pilot
project was developed to analyze a petroleum production test system.  

%A seo 1 apresenta uma introduo sobre o sistema de teste de produo em tanque e a seo seguinte
%descreve a modelagem B e B \textit{assembly}. A seo 3 mostra a simulao do \textit{software}
%desenvolvido, o que foi realizado para testar o seu funcionamento. Finalmente, a ltima seo 
%apresenta as consideraes finais sobre a modelagem desse estudo de caso.


\subsection{Petroleum production test system}

%\subsection{Teste de produo em tanque}

% Intro % O que  isso ?
%O teste de produo  ``o processo usado para o acompanhamento do desenvolvimento da produo de um
%campo de petrleo, o qual  executado em cada poo deste campo numa frequncia previamente definida''
%\cite{LAUT_SERGIO}. Nesse processo so analisadas as caractersticas do leo, gs e gua extrados, tais como:
%volume, concentrao de gua, temperatura, entre outras.	

The production test is ``the process used to  monitor the production of an oil field, this process is executed
in each oil field in predefined frequency'' according to \cite{LAUT_SERGIO}. In
this process are analyzed characteristics (concentration of water, volume and temperature) from oil, gas and water.

%% Porque modelar isso ? O que pode melhorar ?
%Esse tipo de teste possui um papel importante no processo de extrao. Ele  fundamental
%para avaliar a capacidade de extrao dos poos e para designar o pagamento dos impostos governamentais, o pagamento de \textit{royalties} aos
%municpios, as participaes especiais e as participaes aos proprietrios de terra. No entanto,
%atualmente, segundo registros dos testes no sistema de informao, 10\% deles so falhos~\cite{LAUT_SERGIO}. Logo,  importante que
%esses testes obtenham a melhor preciso possvel, a fim de garantir uma melhor qualidade, credibilidade e
%transparncia.


This production test system has a important purpose in the process of extracting
the oil. It is required to analyze the production capacity of wells and calculate
the taxes government, special participations and participations for landowners.
However, based in registers of test of information system, 10\% of production
tests are failed tests~\cite{LAUT_SERGIO}. So, we have developed an embedded
software verified until the assembly level to help the production test. Actually,
the developed software is simplified, because its main objective is to evaluate
and to improve the verification until assembly level.



% Simplificao/abstrao de detalhes no relevantes
%O sistema de teste de produo  utilizado para controlar e avaliar a produo de petrleo. Ele possui um
%sistema supervisrio que calcula a produo de petrleo e controla as vlvulas de acordo com os estados do
%sistema, do sensor de interface e do radar. O radar informa o nvel total do fluido no tanque e o
%sensor de interface informa a concentrao de gua na emulso em um ponto local independente da
%densidade, viscosidade e temperatura de operao, o que ajuda a identificao do nvel da interface. Esse sistema  complexo
%e pode ser considerado sob vrios pontos de vista, no entanto, ele  simplificado nessa proposta at o nvel de abstrao
%adequado para facilitar o entendimento. 

%Uma srie de tcnicas e
%cuidados fsicos deve ser aplicada para realizao correta dos testes de produo. Dessa forma, o sistema de teste
%envolve uma considervel complexidade. Alm disso, os trabalhos de~\cite{LAUT_SERGIO,LAUT_LIMA} definem vrios
%detalhes fsicos e parmetros para melhorar a qualidade dos testes, os quais foram obtidos e aprimorados aps
%experimentos em campo. Esses detalhes podem ser consultados nos trabalhos citados, e nesse trabalho 
%apresentada apenas uma viso geral do problema e a especificao de uma parte do sistema.

The production test system is used to control and to evaluate the oil production. It has a system supervisor that calculate 
the oil production and control the valves based in state of system and informations from sensor interface and radar. 
The radar informs the total level of fluid in the tank and the interface sensor informs the concentration of water in oil that helps
to identify the level of interface oil and water. Several physical precautions and techniques can be applied to realize correctly the
production system test. 




% % Como funciona o estudo de caso?
% O teste de produo, resumidamente, possui trs fases de acordo
% com~\cite{LAUT_SERGIO}. Primeiramente, inicia a fase de condicionamento, o
% sistema de controle do tanque  atualizado com dados coletados do ltimo teste,
% o sistema mantm o poo alinhado\footnote{Um poo est alinhado quando as
% vlvulas da tubulao direcionam o fluxo do poo para o tanque.} e ao final dessa fase a vlvula de drenagem  fechada.
% Em seguida, inicia a fase de enchimento e decantao, logo aps o enchimento e
% a espera, que pode variar de 8 a 20 horas de decantao, comea a fase de
% drenagem. Nessa ltima fase, o sistema deve
% controlar a vlvula de drenagem para no permitir fluir o leo extrado e calcular a sua quantidade.
% E esse clculo  o objeto de interesse do presente estudo de caso. 

The production test has basicly three phases according to~\cite{LAUT_SERGIO}.
First, begin the conditioning phase, the control system of the tank is updated
with data collected from the last test, the system will keep the well aligned 
\footnote{A well is aligned when the valves direct the flow pipe from the well
to the tank.} and the end of this phase the drain valve is closed.

Then the process of filling and decanting begins, after filling and waiting,
which can range 80-20 hours of decanting, draining stage begins. On that last one phase, the
system must control the drain valve to not allow the oil from flowing and to
estimate its quantity. And this calculation is the object of interest of this
case study.

As trs fases citadas so exibidas na mesma ordem na Figura~\ref{fig:EstudoDeCaso}. Nessa figura 
possvel observar os dispositivos utilizados no teste de produo e os estados do tanque
em cada fase.

\begin{figure}[h] \centering \includegraphics[width=1.\textwidth]{images/FasesEstudoDeCaso.png}
\caption{Fases do teste de produo.}
\label{fig:EstudoDeCaso}
\end{figure}

Na fase de drenagem, o nvel de leo desce relativamente rpido at aproximar-se do sensor de interface.
Nesse instante a vlvula de drenagem comea a fechar lentamente e, consequentemente, diminui a
velocidade de  sada do fluido. Todo esse cuidado  importante para evitar a formao de vrtice\footnote{Vrtice
 disposio concntrica e raiada do fluido, ou seja, redemoinho ou pequenas
ondas.}, o que afeta diretamente as propriedades do leo extrado.


% [Dvidas]
% - O sistema de automao usa clp (microcontrolador), ok? Sim Onde? No controle da vlvulas, no recebimento das
% informaes e clculo de nvel. Mais detalhes podem ser obtidos na dissertacao de LIMA
% - O  computador supervisrio ? Apenas monitora e envia comandos! O microcontrolador  quem trabalha mesmo! Mais
% metalhes na {LAUT_LIMA}
% - 

%\begin{figure}[h]
%\centering 
%\includegraphics[width=.8\textwidth]{images/fluxograma_teste_drenagem.png}
%\includegraphics[width=0.95\textwidth]{images/diagrama_de_atividades.png}
%\caption{Diagrama de atividades do sistema de controle da vlvula de drenagem do teste de produo
%\cite{LAUT_SERGIO}.}

%\label{fig:FluxogramaEstudoDeCaso}
%\end{figure}

%A Figura~\ref{fig:FluxogramaEstudoDeCaso} mostra o diagrama de atividades sobre o sistema de controle da
%vlvula de drenagem.
% Contudo, para melhor entender o diagrama  necessrio conhecer alguns conceitos: BSW
% a abreviao de \textit{Basic Sediments and Water} e mede a proporo de gua e sedimentos no fludo
%extrado; BSWe mede a proporo do volume de gua contido na emulso gua e leo entre o volume total
%dessa emulso; CW (\textit{cut water}) representa a capacidade do leo emulsionado reter mais ou menos
%gua. De acordo com \cite{LAUT_SERGIO}, o CW  definido no programa como 20\% ou 40\%, conforme a
%densidade do fluido; e esses valores foram pr-definidos aps experimentos em campo. O sistema de controle
%da vlvula de drenagem comea inicializando as variveis do sistema, esses valores so ajustados de acordo
%com o teste realizado anteriormente e experimentos. Em seguida, o sistema passa a monitorar o estado do
%sensor e do radar. O sistema vai ajustando lentamente o nvel de abertura da vlvula de drenagem at o
%sensor de interface identificar leo. Finalmente, o processo de teste termina.

% Paragrafo de acima adaptado em baixo

Para melhor entender a fase de drenagem  importante conhecer o conceito de BSW, a abreviao de
\textit{Basic Sediments and Water}, que representa a proporo de gua e sedimentos no fludo extrado.
%; BSWe
%mede a proporo do volume de gua contido na emulso gua e leo entre o volume total dessa emulso;
% CW (\textit{cut water}) representa a capacidade do leo emulsionado reter mais ou menos gua. De acordo
% com \cite{LAUT_SERGIO}, o CW  definido no programa como 20\% ou 40\%, conforme a densidade do fluido; e
% esses valores foram pr-definidos aps experimentos em campo.
De acordo com o valor do BSW histrico do poo e outras propriedades do fludo, o sistema estima o nvel
da interface gua e leo.
% O sistema de controle da vlvula de drenagem comea inicializando as variveis do sistema, esses valores
% so ajustados de acordo com o teste realizado anteriormente e experimentos.
Em seguida, o sistema passa a controlar a vlvula de drenagem e a monitorar o estado do sensor e do radar.
O sistema vai ajustando lentamente o nvel de abertura da vlvula de drenagem at o sensor de interface
identificar a emulso gua e leo. Finalmente, o processo de teste termina.

% Motivao para o que pretendemos modelar
Como uma medio exata reduz sensivelmente a margem de erro,
a tcnica desenvolvida por \cite{LAUT_SERGIO} pretende identificar com boa
exatido o atual nvel da lmina de leo atravs das informaes seguintes: valor
do sensor de interface,  nvel do tanque obtido pelo radar e outros parmetros
obtidos atravs de experimentos. Porm, uma garantia matemtica sobre o correto
funcionamento do sistema  fundamental. Assim, um cuidado especial deve ser
realizado nesse sistema.

% De que forma ?  O sistema verificado pode atuar ? Como um sistema redundante, visto o grau de confiana
Para essa finalidade, um \textit{software} foi especificado, verificado, implementado e simulado. A princpio, o \textit{software}
desenvolvido pode atuar como um sistema redundante na plataforma Z80 para interagir com os dispositivos e o sistema supervisrio.
Esse \textit{software} apenas realiza um clculo relativo a produo de leo, com a finalidade de avaliar se o sistema est funcionando corretamente.

% O que pretende-se modelar ? O que foi feito ?
%Assim, o software foi implementado em \textit{assembly} e simulado um
%\textit{software} para calcular um fator de proporo de leo bruto e gua livre.

Aparentemente, o projeto de desenvolvimento desse \textit{software}  uma atividade relativamente simples,
porm como a tcnica de verificao utilizada at o nvel de \textit{assembly}  completamente inovadora,
ento surgiram algumas dificuldades iniciais que levaram tempo para ser solucionadas. A seo seguinte
apresenta mais detalhes sobre a modelagem desse \textit{software}. 
%Essas funcionalidades foram modeladas em B
%e apresentadas nas duas sees seguintes.




%[explicar as conexo/comunicao entre os dispositivos]
 % Para realizar a comunicao entre os dispositivos sero utilizados conversores analgico/digital. 
 % As informaes esto representanda em 8 bits.
 % Explicar o Wait bit de espera :D

% \subsection{Modelagem B do controle da vlvula de drenagem}
% \label{sec:Modelagem B do controle da vlvula de drenagem}
% 
% %[Explicar o objetivo do modelo]- princ
% [Rascunho]
% O obejtivo principal da modelagem apresentada nesta seo  especificar a parte essencial do controle da
% vlvula de drenagem. Como visto anteriormente na fase de drenagem, essa vlula  varia o
% estado de abertura de acordo com dois critrios: o nvel da lmina de leo ou sensor de interface, o qual 
% identifica leo ou gua no fundo do tanque. Considerando que se o sensor de interface
% indica a presena de leo, ento o sistema deve fechar a vlvula do dreno. Caso contrrio, ou seja,
% indica a presena de gua livre, ento o sistema deve ajustar a abertura da vlvula proporcionalmente ao
% nvel de gua livre.
% 
% 
% % O software que faz controle da vlvula de drenagem pode ser separado em trs partes:
% % Clculo do nvel inicial ( multiplicao e condicional \ldots )
% % Atualizao do nvel inicial ( Uma subtrao e atualizao da varivel )
% % Controle da abertura da vlvula ( Atualizao do controle da vlvula )
% % A modelagem dessa seo preocupa-se com o controle da vlvula de abertura.
% 
% 
% Como visto na Figura \ref{fig:FluxogramaEstudoDeCaso} o valor da vlvula  atualizado aproximadamente em
% intervalos de 15 cm. Contudo, segundo \cite{LAUT_SERGIO}   sugerido o uso de uma funo do tipo rampa
% $valve=k*t$, a fim de evitar fechamentos bruscos. Onde, $valve$  o percentual de abertura, $k$  uma
% constante e $t$  o tempo. Baseado na funo utilizada atualmente, sugiro a seguinte funo: $valve = k*H
% + c1$. Onde, $H$  o nvel de gua livre, $k$  igual  $0,5$ e $c1$  uma constante para abertura
% adicional, o qual pode ser ajustado para evitar um tempo excessivo no processo de drenagem. 
% 
% A Figura~\ref{fig:GraficoFuncoes} ilustra as funes de controle da vlvula de drenagem, o eixo vertical
% representa o percentual de abertura da vlvula de drenagem e o eixo horizontal representa $H$ (o nvel de
% gua livre), o que  inversamente proporcional ao tempo de drenagem.
% 
% A funo representada em linha azul  a utilizada atualmente, a mesma descrita na Figura 
% \ref{fig:FluxogramaEstudoDeCaso}. A representada em linha vermelha  a proposta por esse trabalho, essa
% possui uma maior abertura inicial (100\%) e fechamento mais suave, o que reduz o tempo de
% drenagem e evita a formao de vrtice.
% 
% 
% \begin{figure}[h]
% \centering 
% %\includegraphics[width=.8\textwidth]{images/fluxograma_teste_drenagem.png}
% \includegraphics[width=0.99\textwidth]{images/Grafico_funcoes_da_valvula.png}
% \caption{Grfico das funes que controla a vlvula de drenagem..}
% 
% \label{fig:GraficoFuncoes}
% \end{figure}
% 
% Manipulando a funo ($valve = 0.5*H + c1$) e substituindo $H$ pelo parmetro $level$ temos a seguinte
% funo $valve = level/2 + c1$. O sistema tambm deve levar em considerao a informao obtida pelo
% sensor de interface, o que informa a presena de gua livre no fundo do tanque. Dessa forma, a operao
% B seguinte modela essa funcionalidade. A operao ``ControlValve'' recebe como parmetro o nvel de gua
% livre ($level$) e o parmetro ($water$) para calcular a abertura da vlvula de drenagem adequada.
% 
% \begin{tabular}[c]{l}
% \hspace*{0.20in}\bf ControlValve\rm (\it level\rm , \it water\rm )\rm =\\
% \hspace*{0.20in}\bf PRE\\
% \hspace*{0.40in}\it level\hspace*{0.10in} $\in$  \rm 0 $\upto$ \rm 2\rm 0\rm 0  $\land$  \it water 
% $\in$  \rm 0 $\upto$ \rm 1\\
% \hspace*{0.20in}\bf THEN\\
% \hspace*{0.40in}\bf IF \it water \rm = \rm 1 \bf THEN \it valve \rm := \it level $\div$ \rm 2 \rm + \it
% c1\\
% \hspace*{0.40in}\bf ELSE \it valve\rm :=\rm 0 \bf END\\
% \hspace*{0.20in}\bf END
% \end{tabular}
% 
% O primeiro refinamento dessa operao para o nvel de assembly  representado a seguir no texto.
% Um fato interessante  que ele aproveita-se da propriedade da representao em \textit{bits}. Essa
% propriedade diz que a rotao  direita de um vetor de bits  semnticamente equivalente  diviso por
% $2^{n}$, onde $n$  o nmero de rotaes. Na operao de rotao $\mathit{rotateright}$ $n$  igual  1,
% porm essa  uma rotao circular, ou seja, o bit menos significativo  copiado para o bit mais
% significativo. Para tornar a equivalente  diviso por dois  o bit mais significativo  zerado atravs
% da funo $\mathit{bitclear}$.
% 
% \begin{tabular}[c]{l}
% \hspace*{0.15in}\bf ControlValve \rm ( \it level \rm , \it water \rm ) \rm =\\
% \hspace*{0.15in}\bf PRE\\
% \hspace*{0.35in}\it level  $\in$  \rm 0  $\upto$  \rm 2\rm 5\rm 5  $\land$  \it water  $\in$  \rm 0 
% $\upto$  \rm 1\\
% \hspace*{0.15in}\bf THEN\\
% \hspace*{0.35in}\bf IF \it water \rm = \rm 1\\
% \hspace*{0.35in}\bf THEN\\
% \hspace*{0.55in}\bf IF \it level  $\in$  \rm 2\rm 0\rm 1 $\upto$ \rm 2\rm 5\rm 5 \bf THEN \it valve\rm
% :=\rm 1\rm 0\rm 0\\
% \hspace*{0.55in}\bf ELSE \it valve \rm := \it byte\_uchar\rm (\it bitclear\rm (\it rotateright\rm (\it
% uchar\_byte\rm (\it level\rm )\rm )\rm ,\rm 7\rm )\rm )\rm +\it c1 \\
% \hspace*{0.55in}\bf END\\
%  \hspace*{0.35in}\bf ELSE\\
% \hspace*{0.55in}\it valve \rm := \rm 0\\
% \hspace*{0.35in}\bf END\\
% \hspace*{0.15in}\bf END\\
% \end{tabular}
% 
% 
% A seguir  ilustrado o modelo em nvel de assembly. 
% \begin{tabular}[c]{l}
% \ldots
% \end{tabular}
% 
% 
% Esse cgigo assembly foi simulado em \cite{Simulator_z80}. A Figura\ref{fig:control_valvula} ilustra o
% final da execuo os valores de entrada \ldots e sada \ldots
% 
% \begin{figure}[h]
% \centering 
% \includegraphics[width=0.45\textwidth]{images/Simulator_main.png}
% \includegraphics[width=0.45\textwidth]{images/Simulator_Execution.png}
% \includegraphics[width=0.45\textwidth]{images/Simulator_IO_ports.png}
% \includegraphics[width=0.45\textwidth]{images/Simulator_Peripheral_Devices.png}
% \caption{Simulao do controle da vlvula de drenagem.}
% \label{fig:control_valvula}
% \end{figure}
% 
% 
% 
% [abstraes]- princ 
% 
% [explicar a modelagem]
% Quais as entradas e sadas do programa ?
% [Colocar as images de simulao do Z80]
% [explicar as esttisticas] [Explicar as dificuldades] 
% [explicar as regras utilizadas]
% % DICAS PARA DISSERTAO
% % 
% % -> Explicar uma das maiores dificuldades atuais! Que  a pouca simplificao realizada, o histrico que  mantido!
% % A simplificao das expresses poderia ser mais especfica. As regras de simplificao utilizadas no AtelierB muitas vezes perdem "informaes importantes".
% % [Colocar um exemplo pequeno antes da simplificao e aps a simplificao.]
% % 
% % Existem duas solu
% % - Simplifificar utilizando novas regras
% % - Utilizar o ambiente do ABTools e aproveitar o gerador de obrigaes de prova e simplificar as expresses.
% % 
% % 
% % Vantagens em calcular somente o nvel:
% % - Pode-se se adequar a qualquer tamanho de tanque.
% % Assim, o nvel e o determinado tanque que deve informar a quantidade de leo produzido.
% % 
% % Posso pegar as obrigaes de prova e tentar explicar o que  provado!?!
% % * Na documentao colocar o nmero de provas bvias e no obvias
% % 
% % -> Na concluso colocar o nmero total de obrigaes de provas no obvias realizadas!!!

\subsection{Modelagem B } 
%e o \textit{software} do clculo dos fatores de leo bruto e gua livre produzidos}
\label{sec:estudo_caso}

% Overview 
% [Explicar o objetivo do modelo]- princ
% [explicar a modelagem]
% - inicial, implementao, explicar o que refinamento garante,  e assembly cdigo, explicar o
% invariante, as entradas e saidas.
% [explicar as esttisticas]
% [Processo de prova](Pouca coisa,algumas linhas) citar o comando que resolveu 465 automaticamente entre
% 568,  explicado em anexo.
% [Simulao]
% Explicar as images, a entrada e sada \ldots
% [Concluses]
%
 

% Overview
A presente seo apresenta a modelagem B e o \textit{software} do clculo do fator de proporo de
leo bruto (emulso gua e leo) e  gua livre produzidos. 

% [Ressalva -> onde tiver nvel substituir por proporo]
Os fatores de proporo de leo bruto e gua livre so determinados atravs de informaes obtidas na
fase de drenagem. As informaes utilizadas so os nveis do tanque: inicial (tanque cheio) e final (tanque com
apenas leo bruto) da fase de drenagem. Portanto, a subtrao desse dois valores determina um fator de
proporo de gua livre produzida e o nvel final do tanque determina um fator de proporo de leo bruto
produzido. Para determinar exatamente a quantidade de leo e gua livre,  necessrio que o resultado
seja multiplicado por um fator de correo, o qual deve representar as distores e o formato do tanque,
j que o tanque no tem um formato perfeitamente cilndrico. Dessa forma, esse \textit{software}
embarcado torna-se genrico para qualquer formato de tanque.



% Modelagem funcional
A modelagem  iniciada com o modelo funcional \textit{TestCalc}. Esse modelo contm duas variveis
\textit{oil\_factor} e \textit{free\_water\_factor} que representam respectivamente o fator final de leo e
o de gua livre. A seguir,  apresentado o invariante e a operao do modelo funcional. O invariante
declara o tipo das variveis como $\mathit{UCHAR}$, um inteiro positivo de 8 \textit{bits}, ou seja, pertencente ao
intervalo de 0 at 255. A operao recebe como parmetro o valor inicial e final do nvel do tanque e
ento calcula o fator de leo e gua livre. Uma pr-condio dessa operao  que o nvel inicial do
tanque cheio deve ser maior ou igual ao nvel aps a remoo da gua livre. Isso  uma simplificao e 
evita que seja realizado tratamento de exceo at o nvel de \textit{assembly} para esse cdigo.

\small{
\begin{sloppypar}
%\bf MACHINE\\
%\hspace*{0.20in}\it TestCalc\\
% \bf SEES\\
% \hspace*{0.20in}\it SCHAR\_DEFINITION\rm , \it UCHAR\_DEFINITION\\
% \bf VARIABLES\\
% \hspace*{0.20in}\it oil\_factor\rm ,\it free\_water\_factor\\
\hspace*{-0.30in}\bf INVARIANT\\
\hspace*{0.40in}\it oil\_factor  $\in$  \it UCHAR  $\land$  \it free\_water\_factor  $\in$  \it UCHAR\\
\bf OPERATIONS\\
\hspace*{0.20in}\bf update\_factor\rm (\it initial\_level\rm , \it final\_level\rm ) \rm =\\
\hspace*{0.20in}\bf PRE\\ 
\hspace*{0.40in}\it initial\_level  $\in$  \it UCHAR  $\land$  \it final\_level\hspace*{0.10in} $\in$ 
\it UCHAR  $\land$\\
\hspace*{0.40in}\it final\_level  $\leq$  \it initial\_level\\ 
\hspace*{0.20in}\bf THEN\\
\hspace*{0.40in}\it free\_water\_factor \rm := \it initial\_level \rm - \it final\_level $\para$\\ 
\hspace*{0.40in}\it oil\_factor \rm := \it final\_level\\
\hspace*{0.20in}\bf END
%\bf END\\
\end{sloppypar}
}

A operao \textit{update\_factor} do modelo funcional \textit{TestCalc}  similar 
sua modelagem algortmica, exceto o fato das substituies no acontecerem em paralelo, mas acontecem
em sequncia no modelo algortmico, ento o refinamento da modelagem algortmica foi verificado e a sua 
apresentao  omitida aqui.



% 
% \small{
% \begin{sloppypar}
% \bf INVARIANT\\
% \hspace*{0.20in}\it oil\_factor  $\in$  \it UCHAR  $\land$  \it free\_water\_factor $\in$ \it UCHAR\\
% \bf INITIALISATION\\
% \hspace*{0.20in}\it oil\_factor \rm := \rm 0 \rm ;\hspace*{0.20in}\it free\_water\_factor\rm :=\rm 0\\
% \bf OPERATIONS\\
% \hspace*{0.15in}
% 
% \hspace*{0.20in}\bf update\_factor\rm (\it initial\_level \rm , \it final\_level\rm ) \rm =
% 
% \hspace*{0.20in}\bf ASSERT \it initial\_level  $\in$  \it UCHAR  $\land$  \it final\_level  $\in$  \it UCHAR
% 
% \hspace*{0.45in} $\land$  \it initial\_level $\geq$  \it final\_level
% 
% \hspace*{0.20in}\bf THEN
% 
% \hspace*{0.40in}\bf BEGIN
% 
% \hspace*{0.60in}\it free\_water\_factor \rm := \it initial\_level \rm - \it final\_level\rm ;
% 
% \hspace*{0.60in}\it oil\_factor \rm := \it final\_level
% 
% \hspace*{0.40in}\bf END
% 
% \hspace*{0.20in}\bf END
% \end{sloppypar}
% }

Parte da modelagem B no nvel de \textit{assembly}  representada a seguir. Ela  especificada no modelo
\textit{TestCalc\_basm} e possui a mesma semntica de manipulao das variveis que o modelo abstrato
(\textit{TestCalc}), entretanto utiliza operaes que representam instrues \textit{assembly} de
uma instncia do modelo do Z80 para manipular a sua memria. 

A clusula invariante estabelece a relao das variveis do modelo inicial (\textit{free\_water\_factor} e
\textit{oil\_factor}) com os valores dos endereos 2 e 3 da porta de entrada e sada; para estabelecer
essa relao so utilizadas funes que convertem valores da representao binria para representao de
inteiro e vice-versa. Dessa forma, a verificao do refinamento garante que as operaes do modelo B
\textit{assembly} so semnticamente equivalentes  s operaes do modelo mais abstrato de acordo com a
relao estabelecida entre as variveis no invariante.

\small{
\begin{sloppypar}
\hspace*{-0.30in}\bf IMPORTS\\
\hspace*{0.20in}\it Z80\\
\bf INVARIANT\\
\hspace*{0.20in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 2\rm )\rm )\rm ) \rm
=\hspace*{0.10in}\rm (\it free\_water\_factor \rm )  $\land$\\
\hspace*{0.20in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 3\rm )\rm )\rm ) \rm
=\hspace*{0.10in}\rm (\it oil\_factor\rm )
% \bf INITIALISATION\\
% \hspace*{0.20in}\it ext\_update\_io\_ports\rm (\rm 2\rm ,\it uchar\_schar\rm (\rm 0\rm )\rm )\rm ;\\
% \hspace*{0.20in}\it ext\_update\_io\_ports\rm (\rm 3\rm ,\it uchar\_schar\rm (\rm 0\rm )\rm )\\
\end{sloppypar}
}

% entrada e saida%
A seguir  apresentada a operao $\mathit{update\_factor}$ utilizando instrues em nvel de
\textit{assembly}. Essa operao possui a mesma assinatura que o modelo mais abstrato, e os parmetros
recebidos so convertidos para representao em binrio e passados para a operao de atualizao das
portas do microcontrolador ($\mathit{ext\_update\_io\_ports}$).
% Explicao geral do program
Sucintamente, a sequncia de instrues ilustradas a seguir realiza os seguintes procedimentos. As cinco
primeiras instrues representam apenas a cpia dos dados externos ao microcontrolador para os
registradores de memria ``A'' e ``C''. A instruo seguinte realiza uma subtrao, ento as demais copiam
os fatores de proporo de gua livre e leo bruto respectivamente para as portas 2 e 3. O leitor pode
consultar o anexo desse trabalho para entender detalhes da especificao de cada instruo e o invariante
completo da operao $\mathit{update\_factor}$ ilustrada a seguir.


   
% Explicao sobre a construo do invariant
\newpage

\small{
\begin{sloppypar}
%\hspace*{0.20in}\bf OPERATIONS\\
\hspace*{-0.30in}\bf update\_factor\rm (\it initial\_level\rm , \it final\_level\rm ) \rm =\\
\hspace*{0.20in}\it ASSERT\\ 
\hspace*{0.40in}\it initial\_level  $\in$  \it UCHAR  $\land$  \it final\_level\hspace*{0.10in} $\in$ 
\it UCHAR%\\
\hspace*{0.00in} $\land$  \it final\_level  $\leq$  \it initial\_level\\ 
\hspace*{0.20in}\bf THEN\\
\hspace*{0.40in}\bf VAR \it local\_pc \bf IN
\hspace*{0.20in}\it local\_pc \rm := \rm 0\rm ;
\hspace*{0.20in}\bf set\_pc\rm (\it local\_pc\rm )\rm ;\\
\hspace*{0.60in}\bf WHILE \it local\_pc $<$ \rm 9 \bf DO\\
\hspace*{0.80in}\bf CASE \it local\_pc \bf OF\\
\hspace*{1.00in}\bf EITHER \rm 0 \bf THEN
\bf ext\_update\_io\_ports\rm (\rm 0\rm ,\it uchar\_schar\rm (\it initial\_level\rm )\rm
)\rm ;\\
\hspace*{2.45in}\bf IN\_A\_9n0\rm (\rm 0\rm )\\
\hspace*{1.00in}\bf OR \rm 1 \bf THEN\hspace*{0.50in}\bf LD\_r\_r\_\rm (\it b0\rm ,\it a0\rm )\\
\hspace*{1.00in}\bf OR \rm 2 \bf THEN
\hspace*{0.47in}\bf ext\_update\_io\_ports\rm (\rm 1\rm ,\it uchar\_schar\rm (\it final\_level\rm
)\rm)\rm ;\\ \hspace*{2.47in}\bf IN\_A\_9n0\rm (\rm 1\rm )\\
\hspace*{1.00in}\bf OR \rm 3 \bf THEN \hspace*{0.47in}\bf LD\_r\_r\_\rm (\it c0\rm ,\it a0\rm )\\
\hspace*{1.00in}\bf OR \rm 4 \bf THEN \hspace*{0.47in}\bf LD\_r\_r\_\rm (\it a0\rm ,\it b0\rm )\\
\hspace*{1.00in}\bf OR \rm 5 \bf THEN \hspace*{0.47in}\bf SUB\_A\_r\rm (\it c0\rm )\\
\hspace*{1.00in}\bf OR \rm 6 \bf THEN \hspace*{0.47in}\bf OUT\_9n0\_A\rm (\rm 2\rm )\\ 
\hspace*{1.00in}\bf OR \rm 7 \bf THEN \hspace*{0.47in}\bf LD\_r\_r\_\rm (\it a0\rm ,\it c0\rm )\\
\hspace*{1.00in}\bf OR \rm 8 \bf THEN \hspace*{0.47in}\bf OUT\_9n0\_A\rm (\rm 3\rm )\\ 
\hspace*{1.00in}\bf END
\hspace*{0.20in}\bf END\rm ;
\hspace*{0.20in}\it local\_pc  $\leftarrow$  \bf get\_pc\\
\hspace*{0.70in}\bf INVARIANT\\
\hspace*{0.80in}\it local\_pc  $\in$  \rm 0 $\upto$ \rm 9  $\land$  \it rgs8  $\in$  \it id\_reg\_8 
$\fun$  \it BYTE\\
\hspace*{0.80in} $\land$  \it r\_\hspace*{0.10in} $\in$  \it BYTE  $\land$  \it io\_ports  $\in$  \it
BYTE  $\fun$  \it BYTE\\
\hspace*{0.80in} $\land$  \it pc  $\in$  \rm 0 $\upto$ \rm 9  $\land$  \it free\_water\_factor  $\in$ 
\it UCHAR  $\land$\\
\hspace*{0.80in}\rm (\it local\_pc \rm = \rm 0  $\implies$  \rm ( \it pc \rm = \rm 0  $\land$  \it
instruction\_next\rm (\it pc\rm ) \rm = \rm 1  $\land$\\
\hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 2\rm )\rm )\rm ) \rm
=\hspace*{0.10in}\it free\_water\_factor  $\land$\\
\hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 3\rm )\rm )\rm ) \rm
=\hspace*{0.10in}\it oil\_factor \rm ) $\land$\\
\hspace*{1.10in}\ldots\\ 
% \hspace*{0.80in}\rm (\it local\_pc \rm = \rm 1  $\implies$  \rm ( \it instruction\_next\rm (\it pc\rm )
% \rm = \rm 2  $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 0\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it initial\_level  $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm ( \it rgs8\rm (\it a0\rm ) \rm ) \rm = \rm ( \it initial\_level \rm
% )\hspace*{0.15in} $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 2\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it free\_water\_factor  $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 3\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it oil\_factor \rm ) \rm ) $\land$\\
% \hspace*{0.80in}\rm (\it local\_pc \rm = \rm 2  $\implies$  \rm ( \it instruction\_next\rm (\it pc\rm )
% \rm = \rm 3  $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 0\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it initial\_level  $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm ( \it rgs8\rm (\it b0\rm ) \rm ) \rm = \rm ( \it initial\_level \rm )
% $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm ( \it rgs8\rm (\it a0\rm ) \rm ) \rm = \rm ( \it initial\_level \rm )
% $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 2\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it free\_water\_factor  $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 3\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it oil\_factor \rm ) \rm ) $\land$\\
% \hspace*{0.80in}\rm (\it local\_pc \rm = \rm 3  $\implies$  \rm ( \it instruction\_next\rm (\it pc\rm )
% \rm = \rm 4  $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 0\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it initial\_level  $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 1\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it final\_level  $\land$ \\
% \hspace*{1.10in}\it byte\_uchar\rm ( \it rgs8\rm (\it a0\rm ) \rm ) \rm = \rm ( \it final\_level \rm ) 
% $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm ( \it rgs8\rm (\it b0\rm ) \rm ) \rm = \rm ( \it initial\_level \rm )
% $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 2\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it free\_water\_factor  $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 3\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it oil\_factor \rm ) \rm ) $\land$\\
% \hspace*{0.80in}\rm (\it local\_pc \rm = \rm 4  $\implies$  \rm ( \it instruction\_next\rm (\it pc\rm )
% \rm = \rm 5  $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 0\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it initial\_level  $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 1\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it final\_level  $\land$ \\
% \hspace*{1.10in}\it byte\_uchar\rm ( \it rgs8\rm (\it a0\rm ) \rm ) \rm = \rm ( \it final\_level \rm ) 
% $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm ( \it rgs8\rm (\it c0\rm ) \rm ) \rm = \rm ( \it final\_level \rm ) 
% $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm ( \it rgs8\rm (\it b0\rm ) \rm ) \rm = \rm ( \it initial\_level \rm )
% $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 2\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it free\_water\_factor  $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 3\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it oil\_factor \rm ) \rm ) $\land$\\
% \hspace*{0.80in}\rm (\it local\_pc \rm = \rm 5\hspace*{0.10in} $\implies$  \rm ( \it
% instruction\_next\rm (\it pc\rm ) \rm = \rm 6  $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 0\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it initial\_level  $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 1\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it final\_level  $\land$ \\
% \hspace*{1.10in}\it byte\_uchar\rm ( \it rgs8\rm (\it a0\rm ) \rm ) \rm = \rm ( \it initial\_level \rm )
% $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm ( \it rgs8\rm (\it c0\rm ) \rm ) \rm = \rm ( \it final\_level \rm ) 
% $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm ( \it rgs8\rm (\it b0\rm ) \rm ) \rm = \rm ( \it initial\_level \rm )
% $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 2\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it free\_water\_factor  $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 3\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it oil\_factor \rm ) \rm ) $\land$ \\
% \hspace*{0.80in}\rm (\it local\_pc \rm = \rm 6\hspace*{0.10in} $\implies$  \rm ( \it
% instruction\_next\rm (\it pc\rm ) \rm = \rm 7  $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 0\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it initial\_level  $\land$ \\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 1\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it final\_level  $\land$ \\
% \hspace*{1.10in}\it byte\_uchar\rm ( \it rgs8\rm (\it a0\rm ) \rm ) \rm = \rm ( \rm (\it initial\_level
% \rm - \it final\_level\rm )  $\mod$  \rm 2\rm 5\rm 6\rm )  $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm ( \it rgs8\rm (\it c0\rm ) \rm ) \rm = \rm ( \it final\_level \rm ) 
% $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm ( \it rgs8\rm (\it b0\rm ) \rm ) \rm = \rm ( \it initial\_level \rm )
% $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 2\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it free\_water\_factor  $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 3\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it oil\_factor \rm ) \rm ) $\land$\\
% \hspace*{0.80in}\rm (\it local\_pc \rm = \rm 7\hspace*{0.10in} $\implies$  \rm ( \it
% instruction\_next\rm (\it pc\rm ) \rm = \rm 8  $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 0\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it initial\_level  $\land$ \\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 1\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it final\_level  $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm ( \it rgs8\rm (\it a0\rm ) \rm ) \rm = \rm ( \rm (\it initial\_level
% \rm - \it final\_level\rm )  $\mod$  \rm 2\rm 5\rm 6\rm )  $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm ( \it rgs8\rm (\it c0\rm ) \rm ) \rm = \rm ( \it final\_level \rm ) 
% $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm ( \it rgs8\rm (\it b0\rm ) \rm ) \rm = \rm ( \it initial\_level \rm )
% $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 2\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\rm (\rm (\it initial\_level \rm - \it final\_level\rm )  $\mod$  \rm 2\rm 5\rm 6\rm )
% $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 3\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it oil\_factor  $\land$\\
% \hspace*{0.80in}\rm (\it local\_pc \rm = \rm 8\hspace*{0.10in} $\implies$  \rm ( \it
% instruction\_next\rm (\it pc\rm ) \rm = \rm 9  $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 0\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it initial\_level  $\land$ \hspace*{0.20in}\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 1\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it final\_level  $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm ( \it rgs8\rm (\it a0\rm ) \rm ) \rm = \rm ( \it final\_level\rm ) 
% $\land$ \\
% \hspace*{1.10in}\it byte\_uchar\rm ( \it rgs8\rm (\it c0\rm ) \rm ) \rm = \rm ( \it final\_level \rm ) 
% $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm ( \it rgs8\rm (\it b0\rm ) \rm ) \rm = \rm ( \it initial\_level \rm )
% $\land$\\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 2\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\rm (\rm (\it initial\_level \rm - \it final\_level\rm )  $\mod$  \rm 2\rm 5\rm 6\rm )
% $\land$\\
% \hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 3\rm )\rm )\rm ) \rm
% =\hspace*{0.10in}\it oil\_factor )  $\land$\\ 
\hspace*{0.80in}\rm (\it local\_pc \rm = \rm 9\hspace*{0.10in} $\implies$  \rm ( \it pc \rm = \rm 9 
$\land$\\
\hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 0\rm )\rm )\rm ) \rm
=\hspace*{0.10in}\it initial\_level  $\land$ \hspace*{0.20in}\\
\hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 1\rm )\rm )\rm ) \rm
=\hspace*{0.10in}\it final\_level  $\land$\\
\hspace*{1.10in}\it byte\_uchar\rm ( \it rgs8\rm (\it a0\rm ) \rm ) \rm = \rm ( \it final\_level\rm ) 
$\land$\\
\hspace*{1.10in}\it byte\_uchar\rm ( \it rgs8\rm (\it c0\rm ) \rm ) \rm = \rm ( \it final\_level \rm ) 
$\land$\\
\hspace*{1.10in}\it byte\_uchar\rm ( \it rgs8\rm (\it b0\rm ) \rm ) \rm = \rm ( \it initial\_level \rm )
$\land$\\
\hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 2\rm )\rm )\rm ) \rm
=\hspace*{0.10in}\rm (\rm (\it initial\_level \rm - \it final\_level\rm )  $\mod$  \rm 2\rm 5\rm 6\rm ) 
$\land$\\
\hspace*{1.10in}\it byte\_uchar\rm (\it io\_ports\rm (\it uchar\_byte\rm (\rm 3\rm )\rm )\rm ) \rm
=\hspace*{0.10in}\it final\_level \rm )\rm )\\
\hspace*{0.70in}\bf VARIANT \rm (\rm 9 \rm - \it local\_pc\rm ) \bf END\hspace*{0.50in}\\
\hspace*{0.70in}\bf END
\hspace*{0.20in}\bf END\\
\hspace*{0.40in}\bf END
\end{sloppypar}
}

O invariante do $\WHILE$ deve formalizar o estado e o mapeamento das variveis do modelo abstrato
com os valores dos endereos de memria relacionado. Portanto, para cada iterao do \textit{while}, que
 associada com o valor do contador de programa (\textit{pc}), deve existir uma expresso para realizar
essa formalizao. A clusula variante deve expressar o limite superior do nmero de instrues a ser
executado para cada valor possvel do contador de programa.

Um detalhe interessante desse modelo  que as instrues do Z80 podem receber valores inteiros,
porm o modelo do Z80 representa internamente os dados na notao binria. Essa diferena na representao poderia
dificultar bastante o processo de verificao. No entanto, os tipos, as funes e os lemas construdos
para suportar e converter as duas representaes facilitaram bastante o processo de verificao.


\subsection{Processo de verificao do modelo B assembly}

Esta seo descreve o processo de verificao do modelo B \textit{assembly} \textit{TestCalc\_basm} e o
efeito de uma das tcnicas utilizadas. O modelo \textit{TestCalc\_basm} continha 200 obrigaes de prova
do tipo EBD (Expresses Bem Definidas) e 568 no bvias. As obrigaes de prova EBD foram rapidamente
resolvidas atravs de comandos de prova e do provador interativo. As outras 568 no foram resolvidas to
facilmente. Felizmente, existe um comando de prova extremamente eficiente que agiliza a verificao, pois
esse comando de prova  reusvel em obrigaes de prova semelhantes, as quais so comuns na modelagem B
\textit{assembly}.

Este comando de prova praticamente resolve todas as obrigaes de prova as quais representam um fluxo de
execuo invlido, isto , no caso do modelo \textit{TestCalc\_basm} representam a possibilidade de
fluxos de execuo no lineares. Essas obrigaes de prova so criadas porque o gerador de obrigaes de prova constri frmulas para avaliar todas as posibilidades
do fluxo de execuo do modelo. Como o modelo especificado tem um fluxo de execuo linear, ou
seja, o contador de programa ($\mathit{pc}$) efetua apenas saltos para a instruo seguinte, ento o nmero
de possibilidades do fluxo de execuo  mnimo. Nesse caso, o comando de prova citado ajudou a verificar
rapidamente 465 obrigaes de prova (81\%). Um fato ainda mais interessante  que foi utilizado um \textit{time out}
de um segundo para resolver cada obrigao de prova. Dessa forma, foi necessrio no mximo 465 segundos para resolver 81\%
das obrigaes de prova. As 103 demais obrigaes de prova foram resolvidas interativamente, pois essas eram mais
complexas\footnote{Nenhuma das 103 obrigaes de prova foi resolvida no provador automtico na fora
zero e com um \textit{time out} de 180 segundos.}. Para esse comando de prova funcionar 
importante declarar no invariante do \textit{while} de cada instruo os possveis prximos valores do
contador de programa. Esse e outros comandos de prova podem ser consultados no anexo deste trabalho.

Nesse modelo os passos das provas interativas seguem alguns padres, os quais foram identificados pelo projetista
e isso ajudou bastante a verificao. Contudo, o projetista ainda no conseguiu definir uma sequncia de comandos de prova 
suficientemente genrica para resolver vrias obrigaes de prova entre as 103 no resolvidas
automaticamente. Finalmente, a construo de um invariante vlido e a realizao das provas interativas
do modelo \textit{TestCal\_basm} apresentado anteriormente so as atividades mais complexas do processo
de verificao, j que essas duas atividades consomem aproximadamente 70\% e 80\% de todo o processo de especificao e
 verificao.

\subsection{Simulao do cdigo assembly}

A simulao do \textit{software}\footnote{A sequncia de instrues representadas no modelo
\textit{TestCalc\_basm} formam um \textit{software} em linguagem \textit{assembly} do Z80, o qual 
ilustrado no lado superior direito da Figura~\ref{fig:simulacao}.} tem um papel importante para analisar
seu comportamento, pois, no simulador,  possvel avaliar e manipular os valores dos registradores, da
memria e das portas de entrada e sada. O uso do simulador permite ganhar confiana no programa \textit{assembly}
desenvolvido, assim como no prprio modelo formal do conjunto de instrues do Z80, visto que o manual
possui pequenos erros.

Por conseguinte, do ponto de vista do sistema implantado em campo, o Z80 recebe do radar ou do sistema
supervisrio o valor do nvel do tanque no incio da fase de drenagem. E ao trmino dessa fase, o Z80 recebe em outra porta o
valor do nvel final do tanque. Em seguida, o Z80 deve calcular e disponibilizar em outras duas portas o fator
de gua livre e o do leo bruto produzido.

Esse cdigo \textit{assembly} foi simulado com o aplicativo \cite{Simulator_z80}. A
Figura~\ref{fig:simulacao} ilustra o final da execuo do \textit{software} e os valores dos elementos do microcontrolador.
Todos esses valores do simulador so representados no sistema de numerao hexadecimal e as portas
de entrada e sada, tambm no sistema binrio. A janela do lado superior esquerdo contm
os estados dos registradores do microcontrolador e as opes para controlar a execuo do
programa. A janela superior do lado direito contm o cdigo \textit{assembly} em execuo e uma seta amarela
indicando a posio atual do contador de programa. A janela inferior esquerda contm um editor da
memria de dados do microcontrolador. A janela inferior direita contm as informaes que esto
representadas nas portas de entrada e sada. A porta do endereo \textit{00H} contm o valor inicial do
nvel do tanque (10); a do endereo \textit{01H}, o valor final do nvel do tanque (2); a do endero
\textit{02H}, o fator de proporo de gua livre produzido (8) e do endereo \textit{03H}, o fator de
proporo de leo bruto produzido (2). O leitor pode conferir como cada elemento ilustrado na Figura~\ref{fig:simulacao}
(resgistradores, portas de entrada e sada, interrupes e memria) foi especificado consultando o anexo deste trabalho. 


% [explicar as conexo/comunicao entre os dispositivos]
%Quanto a comunicao entre os dispositivos podem ser utilizados conversores analgico/digital de 8 \textit{bits},
%pois esse  o tamanho do barramento de dados do Z80. Outro detalhe relativo a comunicao  que o Z80
%precisa esperar as informaes estarem disponveis nas portas de entrada de dados para iniciar os
%clculos. Esse detalhe temporal no ser representado na modelagem, pois o \textit{hardware} do Z80 possui
%um bit (\textit{WAIT}) que bloqueia a execuo do \textit{software} e aguarda a informao ser disponibilizada na
%porta de entrada. Maiores detalhes sobre a comunicao dos dispositivos so abstrados, pois esses so
%simples e no est no foco do trabalho.



\begin{figure}[h]
\centering
%\includegraphics[width=0.45\textwidth]{images/Simulator_main.png}
%\includegraphics[width=0.45\textwidth]{images/Simulator_Execution.png}\\
%\includegraphics[width=0.45\textwidth]{images/Simulator_memory.png}
\includegraphics[width=1.0\textwidth]{images/Simulator_Full.png}
%\includegraphics[width=0.45\textwidth]{images/Simulator_Peripheral_Devices.png}
\caption{Janelas do simulador \cite{Simulator_z80}.}
\label{fig:simulacao}
\end{figure}



% Concluso

\subsection{Consideraes finais sobre o estudo de caso}

%[Importncia de ser o primeiro modelo 1 utilizando as bibliotecas]%[Completamente suportado pelo mtodo B, principalmente devido ao uso de funes que convertem as representaes dos sistemas de numerao]
%[A importncia das tcnicas e a experincia adquirida]
%[Explicar como pode ser til para avaliar a vazo]
%[ Finalmente, argumento mais importante : A tcnica est sendo viabilizada,
% pois o maior custo do processo est diminuindo devido aos avanos do atelierb e as tcnicas descobertas  ]


% [Importncia do 1 modelo]
O modelo \textit{TestCalc\_basm} foi o primeiro construdo de acordo com a proposta de [Dantas et al.
2008]  utilizando as bibliotecas de \textit{hardware} e tipos inteiros. Essas bibliotecas contm tipos,
funes e lemas que possibilitaram estabelecer a relao entre o modelo B \textit{assembly} e o modelo
mais abstrato. Essas definies mantiveram a assinatura das operaes do modelo abstrato com relao ao B
\textit{assembly}, simplificaram o processo de verificao e tornaram mais fiel a representao do
microcontrolador, tudo isso sem a necessidade de estender o mtodo B.

% [A importncia das tcnicas e a experincia adquirida]
A elaborao desse modelo foi muito importante para amadurecer o processo de verificao, pois a
construo e verificao do modelo ajudou ao projetista adquirir experincias com o provador interativo e
a descobrir comandos de prova que reduzem significativamente o tempo do processo de prova. Essa
experincia torna mais vivel a especificao de outros \textit{softwares} mais complexos, pois a
maioria dos comandos de provas podem ser usados novamente em obrigaes de prova similares e o padro de
especificao utilizado ajuda na modelagem de novas plataformas. 

%No entanto, esse mesmo \textit{software} poderia ser acoplado em dispositivo \textit{timer} e 
%pois de forma bem eficiente foi resolvida  
%Certamente reduzem bastante o custo de verificao,
%pois o projetista desse modelo compreendeu a construo do invariante para linguagens assembly, 
% possvel aproveitar as caractristicas das provas interativas para realizar algum tipo de automao nessa etapa,
%tudo indica que a construo da clusula invariante pode ser feita por um algortmo simples e    
%[Explicar como pode ser til para avaliar a vazo] ]
%Poderia se avaliando atravs da vazo, mas a modelagem ainda suporta bem aspectos temporais, por outro lado,
%utilizando-se de um dispotivo \textit{timer} esse mesmo \textit{software} poderia calcular o tempo de enchimento do tanque
%a vazo pode ser 

%[ Importncia para rea de petrleo e gs ]
Finalmente, o funcionamento do \textit{software} desenvolvido como um sistema redudante deve oferecer uma melhor confiana e qualidade,
pois o engenheiro responsvel ter mais um meio de comparao dos testes de produo e mais garantias. Essas garantias
devem-se  existncia de um sistema redundante e a sua verificao formal at um dos ltimos nveis de representao
do \textit{software}. Logo, o sistema pode tambm melhorar a eficcia dos testes, visto que menos testes falhos podem existir.






 
% \chapter{Projeto do compilador}
% \label{cap:proj_compilador}
% 
% % Intro
% Esta seo contm informaes importantes sobre o projeto do compilador e
% ferramentas B, as quais podem ser reusadas nesse projeto. Adicionalmente, a atual
% seo apresenta duas abordagens possveis para a construo do compilador. Desde
% j,  importante entender o contexto da relao entre o projeto do compilador e
% o estudo de caso.
% 
% 
% % Porque construir o compilador
% O estudo de caso descrito na seo \ref{sec:estudo_caso} ser refinado at o
% modelo algortmico e posteriormente, o autor desse trabalho ir escrever
% manualmente o programa \textit{assembly} e o modelo B \textit{assembly}
% correspondente. No entanto, esse ltimo passo pode ser automatizado atravs de um
% compilador especfico. Por outro lado, o projeto desse tipo de compilador  uma
% atividade relativamente complexa, pois esse tipo de compilador deve tambm
% introduzir frmulas no modelo B \textit{assembly} para possibilitar o processo
% de verificao, de acordo com o que foi explicado no captulo
% \ref{cap:VerificacaoAssembly}.
% 
% Dessa forma, o presente trabalho fornecer apenas informaes teis para o seu projeto inicial.
% 
% \subsection{Reuso do \textit{parser}}
% % Explicar que  possvel reusar o parser
% Para a construo do compilador  possvel reusar o
% \textit{parser}\footnote{\textit{Parser}  um componente de \textit{software} que
% reconhece uma sequncia de caracteres de entrada (cdigo fonte) e constri uma
% estrutura de dados para representao e manipulao dessa entrada.} de uma outra
% ferramenta. Na comunidade existem vrios \textit{parsers} para mtodo B, no
% entanto ser comparado apenas os quatro mais significativos e viveis. Esses
% \textit{parsers} so utilizados nas seguintes ferramentas:
% \textit{ABTools}, \textit{BSmart/Batcave},  \textit{BParser} e \textit{ComenC}.
% 
% O \textit{ABTools} segundo \cite{DBLP:conf/acsd/Boulanger03}  um ambiente de
% desenvolvimento B composto de \textit{parser}, verificador de tipos, gerador:
% de obrigaes de prova e documentao. \textit{ABTools} foi desenvolvido com o
% intuito de facilitar o desenvolvimento de ferramentas de extenso para linguagem
% B, o que  interessante para o projeto do compilador com verificao em nvel de
% \textit{assembly}. Por outro lado, o \textit{ABTools} no vem sendo muito
% utilizado na indstria, o que no demonstra um forte amadurecimento.
% 
%  
% As ferramentas \textit{BSmart}~\cite{deharbe06developing} e
% \textit{Batcave}\\\cite{Batcave} utilizam um nico \textit{parser}, esse
% \textit{parser}  uma evoluo do utilizado na ferramenta
% \textit{JBTools}~\cite{Tatibouet}. O \textit{parser}  desenvolvido na linguagem
% \textit{Java}~\cite{Java} e utiliza o gerador de \textit{parser}
% Javacc~\cite{Javacc}. \textit{Java} e \textit{Javacc} so bastante conhecidos na
% comunidade e possuem ampla documentao disponvel, o que facilita o
% desenvolvimento do compilador. Por outro lado, segundo~\cite{Fabian2008}, o
% \textit{parser} do \textit{JBTools} usa uma rvore sinttica com elementos
% desnecessrios e ele  difcil de manter e estender. Os empecilhos citados
% levaram  construo de um novo \textit{parser}, chamado \textit{BParser}.
% 
% O \textit{BParser}~\cite{Fabian2008} (\textit{Object Oriented Parser For B Specifications}) foi construdo para ser
% utilizado pelo \textit{ProB}~\cite{proB} e tinha como principais objetivos: melhorar a capacidade de manuteno e
% extenso, e suportar completamente a sintaxe de B. Alm disso, o \textit{BParser} tem cdigo fonte cinco vezes
% menor que \textit{parser} do \textit{JBTools}. Entretanto, o \textit{BParser} apresentou pequenos problemas em testes
% realizados pelo autor desta dissertao, mas eles foram corrigidos rapidamente pelo autor do \textit{BParser}.
% Logo, isso indica que o \textit{BParser} est em fase de amadurecimento. Outro \textit{parser} mais estvel e
% utilizado em escala industrial  o embutido na ferramenta \textit{ComenC}~\cite{ComenC}.
% 
% O \textit{ComenC}  um tradutor de B para a linguagem C. Ele  resultado da convergncia de trabalhos
% entre a indstria e a pesquisa. Dessa forma, o \textit{ComenC} tem uma verso de \textit{software} bem estvel e
% recentemente vem disponibilizando atualizaes com frequncia. Adicionalmente, existe uma ampla documentao
% disponvel sobre o \textit{parser} do \textit{CommenC} e ele segue as especificaes padres da
% linguagem B utilizada na indstria. Portanto, o \textit{parser} do \textit{ComenC}  um forte candidato a ser
% utilizado no projeto do compilador.
% 
% 
% A Tabela \ref{tab:Comparacao_parsers} contm uma sntese comparativa com as principais caractersticas das
% ferramentas, as quais podem ter o \textit{parser} reusados.
% 
% \begin{table}[h]
% \begin{center}
% \begin{tabular}{|l|c|c|c|c|c|c|}
% \hline
%   & \textbf{ABTools}  & \textbf{BSmart/Batcave}  &  \textbf{BParser} &  \textbf{ComenC}  \\
%    \hline
%  Idioma & Francs/Ingls & Portugus/Ingls  &  Ingls/Alemo &  Francs/Ingls  \\
%  \hline
%  Tecnologias & ANTLR & Java/Javacc  &   Java/SableCC & C++/C \\ \hline
%  Cdigo aberto &  Sim &  Sim  &  Sim  & Sim \\ \hline
%  Licena &  \textit{GNU LGPL} &  \textit{GNU LGPL} & No
%  definido &  \textit{GNU GPL}\\ \hline
%  %Ms da ltima verso & 08/2008  & 02/2008 & 05/2009  \\ \hline
%  Apoio & INRETS &  UFRN  & Heinrich-Heine & Clearsy  \\ \hline
% \end{tabular}
% \end{center}
% \caption{Tabela comparativa com caractersticas das ferramentas para o mtodo B.}
% \label{tab:Comparacao_parsers} 
% \end{table}
% 
% 
% \subsection{Abordagens para construo do compilador}
% \label{sec:proj_compilador}
% 
% 
% A princpio, existem duas abordagens possveis para a construo do compilador. Essas abordagens so
% ilustradas atravs de dois diagramas de comunicao da UML, que mostram as colaboraes aps a verificao do
% modelo algortmico.
% 
% A abordagem mais simples  ilustrada no diagrama de comunicao da Figura~\ref{fig:poucoreuso}. Nessa abordagem 
% construdo um nico novo componente de \textit{software}, que aproveita um \textit{parser} desenvolvido anteriormente e
% adiciona a funcionalidade de transformar o modelo algortmico B em \textit{assembly} e B \textit{assembly}. Ento, o
% prprio AtelierB deve verificar a consistncia do cdigo gerado. Logo, essa abordagem  simples, pois o
% desenvolvedor provavelmente deve trabalhar com apenas uma tecnologia e componente de \textit{software}.  
% 
% 
% \begin{figure}[h]
% \centering 
% \includegraphics[width=0.85\textwidth]{images/Diagrama_Comunicacao_Simplificado.png}
% \caption{Diagrama de comunicao do processo de compilao e verificao na abordagem simplificada.}
% \label{fig:poucoreuso}
% \end{figure}
% 
% % Como funciona ?
% Uma segunda abordagem para o projeto do compilador  ilustrada na
% Figura~\ref{fig:altoreuso}. Essa abordagem separa as responsabilidades em vrios
% componentes de \textit{software}. Alm disso, ela intensifica ainda mais o reuso.
% Aps os passos do mtodo B tradicional, a segunda abordagem funciona da seguinte
% forma: inicialmente  utilizado o \textit{ComenC} para gerar cdigo C; na
% sequncia  utilizado o popular compilador \textit{gcc}~\cite{gcc}, ou qualquer
% outro compilador C, para gerar cdigo assembly para o Z80; aps isso, o mdulo de
% \textit{software} ASM2BASM, a ser desenvolvido, deve transformar cdigo \textit{assembly} puro para
% B \textit{assembly}; finalmente, o \textit{AtelierB} deve verificar se o cdigo 
% consistente com relao ao modelo refinado. Essa abordagem no  muito
% recomendada para o desenvolvimento com uma equipe pequena, pois um grande esforo
% ser necessrio para compreender detalhes de todos os componentes de
% \textit{software} envolvidos. Adicionalmente, essa abordagem possivelmente
% dificultar a gerao dos invariantes e variantes do modelo \textit{assembly}.
%  
% 
% \begin{figure}[h]
% \centering 
% \includegraphics[width=0.999\textwidth]{images/Diagrama_comunicacao_com_muito_Reuso.png}
% \caption{Diagrama de comunicao do processo de compilao e verificao na abordagem com alto reuso.}
% \label{fig:altoreuso}
% \end{figure}
% 
% %Resumo da comparao das duas abordagens
% 
% A grande vantagem da abordagem mais simples  a exigncia de uma equipe menor de trabalho. Alm disso, resultados
% iniciais podem ser obtidos mais rapidamente. Por outro lado, a segunda abordagem  mais audaciosa, generalista e
% pode aproveitar a capacidade do \textit{gcc} de gerar cdigo \textit{assembly} para vrias plataformas.
%  
% Finalmente, o projeto do compilador deve evoluir de acordo com as experincias obtidas nesse estudo de caso real.
% Desta forma, as dificuldades e as novas solues encontradas colaboraro diretamente para construo do compilador.
% 
%    
% \subsection{Plano de desenvolvimento dos trabalhos propostos}
% \label{sec:cronograma}
% 
% As atividades discentes planejadas para o segundo semestre deste ano esto relacionadas com: a modelagem e
% verificao do estudo de caso da seo \ref{sec:estudo_caso}; relato de informaes teis ao projeto do compilador;
% e a elaborao da dissertao.
% 
% \begin{enumerate}
% 
% \item A modelagem e a verificao do estudo de caso so realizadas em 4 etapas:
% 	\begin{enumerate}
%       \item A construo e verificao do modelo funcional;
% 	  \item A elaborao e verificao do seu refinamento e modelo algortmico;
% 	  \item A implementao do cdigo \textit{assembly} correspondente;
% 	  \item A construo e verificao do modelo B \textit{assembly}. Essa ltima
% atividade  uma das etapas mais complexas e difceis, no entanto, tal atividade  a mais importante para
% o objetivo desse trabalho.
% \end{enumerate}
% 
% % Inicialmente, os trabalhos sero realizados sobre um subconjunto da linguagem
% % de B. Nesse sentido, uma gramtica BNF foi desenvolvida e est nos anexos desse
% % trabalho (captulo \ref{cap:anexo}).
% \item Quanto ao projeto do compilador citado anteriormente, informaes na
% dissertao sero apenas descritas,  se eventualmente essas forem teis para o
% compilador.
%  
% \item Com relao  dissertao, a escrita ser realizada, aos poucos, com o
% decorrer do desenvolvimento da modelagem e verificao do estudo de caso. Os
% captulos \ref{cap:MetodoB},\ref{cap:VerificacaoAssembly} e
% \ref{cap:trabalhosdesenvolvidos} deste trabalho esto praticamente prontos para
% dissertao. Ento, falta apenas relatar sobre a modelagem do estudo de caso e
% realizar alguns ajustes na introduo e concluses. Finalmente, pouco tempo antes
% da defesa ser intensificada a escrita da dissertao.
% 
% \item Para a defesa ser elaborada a apresentao e a reviso os ltimos detalhes do trabalho. 
% 
% \end{enumerate}
% % Elaborao de estudo de caso - Estudar em mais detalhes o estudo de caso.
% % 							 - Construir um modelo funcional e validar o modelo.
% % 							 - Elaborar os demais modelos algoritmos
% % 							 
% % Compilador 					 - Ser relatado alguma ideia, caso surja.
% % 							 -  
% %  
% % Dissertao					 - Ir elaborando paralelamente de acordo com o desenvolvimento dos trabalhos.
% %\newpage
% 
% % O cronograma para realizao dessas atividades discentes  apresentado na Tabela~\ref{cronograma}.
% % 
% % \newcommand{\drawbox}{\rule[0mm]{10mm}{3mm}}
% % \begin{table}[!h]
% % \begin{center}
% % \begin{small}
% % \begin{tabular}{|c|c|c|c|c|c|}
% % \hline  & {\bf Jul.} & {\bf Ago.}  & {\bf Out.} & {\bf Nov.}  & {\bf Dez.}\\
% % \hline
% % 1(a)   & \drawbox  &   &   &   &   \\
% % 1(b)   & \drawbox  &  \drawbox  &  &   &   \\
% % 1(c)   & \drawbox &   \drawbox &   &   &   \\
% % 1(d)   & \drawbox  & \drawbox  & \drawbox  &   &   \\
% % 2   &   & \drawbox  & \drawbox  & \drawbox  &   \\
% % % 2(c)   &   &   &   &   & \drawbox  \\
% % % 3(a)   &   &  \drawbox & \drawbox  & \drawbox  & \drawbox  \\
% % % 3(b)   &   &  \drawbox & \drawbox  & \drawbox  & \drawbox  \\
% % % 3(c)   &   &   &   &   &   \\
% % 3   & \drawbox  & \drawbox  & \drawbox  & \drawbox  & \drawbox  \\
% % 4   &   &  &   &   & \drawbox  \\  
% % \hline
% % \end{tabular}
% % \end{small}
% % \end{center}
% % \caption{Cronograma para o desenvolvimento das atividades discentes}
% % \label{cronograma}
% % \end{table}
% % 
% 

\section{Verification}
\label{sec:Verification}

[To get new informations from dissertation]
% [O que as provas garantem? citar que dificeis, que he necessherio buscar thecnicas eficientes
% para realizar as provas ]

The proof obligations allow to verify the data types, important system
properties and if the expressions are well-defined (WD). The
properties provide additional guarantees, because they can set many
safety rules. However, the model can be very difficult to prove.
Some statistics are shown below:
%[Groups]
\begin{center}
\begin{tabular}{llll}
\textbf{Group} &  \textbf{Proofs No Obvious} & \textbf{Proofs WD} &   \\ 
Input and Output & 54 & 296  \\ 
Logic and Arithmetic & 134 & 413  \\ 
Manipulation of Bits & 160 & 742  \\ 
Extern actions & 51 & 84  \\
General & 140 & 615  \\
Initialization, Properties and Assertions & 68 & 169  \\
 \textbf{Total} &  607 &  2319  &  %\textbf{Total} 2926 \\
\end{tabular}
\end{center}


% [Conclusao] This project has many proof obligations and
% The construction of then model was a difficult task, as several
% iterations were needed to provide the good library definitions
% as well as to optimize the definition of the functionality of
% the microprocessor instructions by grouping common data
% manipulation into auxiliary functions.

Several iterations were needed to provide the good library definitions as well as
to fine-tune the model of the microcontroller instructions by factoring common
functionalities into auxiliary definitions.


However, few proof commands\footnote{The proof commands are steps that direct the
prover to find the proof, and cannot introduce false hypothesis.} need to be used
to prove most proof obligations. As there are many similar assembly instructions,
some human-directed proofs, when replayed, could discharge other proof
obligations. A good example is a set of 17 proof commands that quickly aided the
verification of 99\% (2295) of WD proofs. We also set up a proving environment
consisting of networked computers to take advantage of the distribution
facilities now provided in the B development environment. Finally, all of the
2926 proof obligations were proved using the tool support of the development
environment.


Organizar melhor o texto abaixo desta seo
____________________________________________

-> Explicar o processo de prova como aconteceu no geral: o que foi utilizado para melhorar. 

-> Explicar os proof commands, como eles funciona (basear no anexo contedo anexo da dissertacao)

-> Estatscas gerais e concluses sobre o processo  de prova


The level of automation of proof process was satisfactory, because the B method, its tools and features were too much explored.
Case the proof process have gotten a low automation then the proof process could be very slow and difficult. Two requirements are important
to verify quickly the proof obligations: a experience with interactive theorem prover from Atelierb, that is acquired from practicing, and 
knowledge about proof commands (mathematical rules)\cite{Manual_MathematicalRules}. Naturally, the statics confirm the good level of proof process
automation: approximately 89\% of obvious proof obligations and 99\% proof obligations well defined were verified automatically.   


Proof commands

A design with good division responsibility of modules reduces efforts. The modularization helps to build two simple libraries, that defines
important basic lemmas, and also separated and organized the instructions specification in different modules, this important to verify the models 
in parallel. 

To verify the proof obligations from different modules were used four computers, each one with two cores. 
The parallelization of proof process also increases many times the processing capacity.






\section{Related works}
\label{sec:relatedworks}
 
There are in the literature of computer science some
approaches~\cite{BHDL_2003,GEMPLUS_99} to model hardware and the virtual machines
using the B method. Then, in both works the B method has been used successfully
to model the operational semantic. However the cost of modeling was still expensive and this
paper quoted some techniques to lower the cost of modeling.
% Although, the modelling of the Z80 do not have modelled some small aspects.


% The objective of researchers


In general, the researchers employing the B method have focused on
more abstract level of description of software.  Considering low-level
aspect, there has been previous work on modelling the Java Virtual
Machine~\cite{GEMPLUS_99}.

The main motivation of our research is the development of verified
software up to the assembly level, which requires specifying the
semantics of the underlying hardware. Thus some aspects were not
modeled in our work such as the execution time of the instructions.
Also we did not consider the micro architecture of the hardware as the scope of
our work does not include hardware verification. However, there are
many other specialized techniques to verify these questions.
 
\section{Conclusions}
\label{sec:conclusions} 

This work has shown an approach to the formal modeling of the instruction set of
microcontroller using the B method. During the construction of this model, some
ambiguities and errors were encountered in the official reference for Z80
microcontroller~\cite{Z80_manual}. As the B notation has a syntax that is not too
distant from that of imperative programming languages, such model could be used
to improve the documentation used by assembler programmers. Besides, the formal
notation used is analyzed by software that guarantees the correctness of typing,
the well-definedness of expressions, in addition to safety properties of the
microcontroller state.


% This research is much interesting to
% design microcontroller. Because, the building of formal model found some erros and ambiguities at the oficial
% manual~\cite{Z80_manual}. The Z80's B model can replace the documentation used by assembler programmers, because the
% formal model represents the instructions effects and the B-method has a easy language, that remembers the pascal
% language. Besides, the formal model restricts the definitions to correct typing, use expressions well-defined and
% allow to verify properties on the model.


% [Trabalhos futuros ]
Future works comprise the development of software with the B method
from functional specification to assembly level, using the Z80 model
presented in this paper. The mechanic compilation from B algorithmic 
constructs to assembly platform is also envisioned.

% The next steps of the work comprises the development of a real study case in the oil area and the
% project of a compiler to aid the automation of verification at the assembly level
 
% The next works are the development of a real study case in the oil area and after the project of a
% compiler to aid the automatization of verification at the assembler level.
  
\paragraph{Acknowledges:}
This work was partially supported by INES (www.ines.org.br), funded by CNPq
grant \ldots
%573964/2008-4 and by CNPq grants 553597/2008-6, 550946/2007-1, and 620132/2008-6..

\bibliographystyle{splncs}
\bibliography{paper}
% [To change the format; to add: thesis suggested by David, Article from ABZ 2010 suggested by David  ]
% \begin{thebibliography}{5}
% 


\end{document}
%
% \bibitem {clar:eke}
% Clarke, F., Ekeland, I.:
% Nonlinear oscillations and
% boundary-value problems for Hamiltonian systems.
% Arch. Rat. Mech. Anal. {\bf 78} (1982) 315--333
% %
% \bibitem {clar:eke:2}
% Clarke, F., Ekeland, I.:
% Solutions p\'{e}riodiques, du
% p\'{e}riode donn\'{e}e, des \'{e}quations hamiltoniennes.
% Note CRAS Paris {\bf 287} (1978) 1013--1015
% %
% \bibitem {mich:tar}
% Michalek, R., Tarantello, G.:
% Subharmonic solutions with prescribed minimal
% period for nonautonomous Hamiltonian systems.
% J. Diff. Eq. {\bf 72} (1988) 28--55
% %
% \bibitem {tar}
% Tarantello, G.:
% Subharmonic solutions for Hamiltonian
% systems via a $\bbbz_{p}$ pseudoindex theory.
% Annali di Matematica Pura (to appear)
% %
% \bibitem {rab}
% Rabinowitz, P.:
% On subharmonic solutions of a Hamiltonian system.
% Comm. Pure Appl. Math. {\bf 33} (1980) 609--633
% \end{thebibliography}
%

