\documentclass{entcs} 
\usepackage{entcsmacro}
\usepackage{graphicx}

\usepackage{listings}
% Define B sintaxe
\lstdefinelanguage{B}  {
keywords={MACHINE, REFINEMENT, REFINES, IMPLEMENTATION, SEES, IMPORTS, SETS, INCLUDES, EXTENDS, CONSTANTS, CONCRETE_CONSTANTS, CONCRETE_VARIABLES, PROPERTIES, DEFINITIONS, VARIABLES, ABSTRACT_VARIABLES, INITIALISATION, INVARIANT, VALUES, OPERATIONS, BEGIN, PRE, THEN, END, NAT, NAT1, BOOL, MAXINT, IF, ELSE, ELSIF, ANY, WHERE, CHOICE, OR, EITHER, SELECT, VAR, IN},
sensitive=true,% 
alsoletter={\$},% 
comment=[l]{\#},% 
string=[b]",% 
string=[b]'% 
}

% Set listing styles
\lstset{ %
%language=Pseudo,                % the language of the code
basicstyle=\footnotesize\ttfamily,            % the size of the fonts that are used for the code
extendedchars=true,
numbers=left,                   % where to put the line-numbers
numberstyle=\tiny,      % the size of the fonts that are used for the line-numbers 
%stepnumber=2,                   % the step between two line-numbers. If it's 1, each line will be numbered
%numbersep=5pt,                  % how far the line-numbers are from the code
%backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
%showspaces=false,               % show spaces adding particular underscores
%showstringspaces=false,         % underline spaces within strings
%showtabs=false,                 % show tabs within strings adding particular underscores
frame=b,   %trBL,                   % adds a frame around the code
stringstyle=\color{white}\ttfamily,
%linewidth=0.8\textwidth, % width of the line
tabsize=2,                      % sets default tabsize to 2 spaces
columns=fixed,
basewidth=.6em,
xleftmargin=20pt,
xrightmargin=5pt,
%captionpos=b,                   % sets the caption-position to bottom
breaklines=true,                % sets automatic line breaking
showspaces=false,           % Leerzeichen anzeigen ?
showtabs=false,             % Tabs anzeigen ?
%backgroundcolor=\color{lightgray},
keywordstyle=\color{red},
showstringspaces=false
%breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
%title=\lstname,                 % show the filename of files included with \lstinputlisting; also try caption instead of title
%escapeinside={\%*}{*)},         % if you want to add a comment within your code
%keywords={}            % if you want to add more keywords to the set
}

\sloppy
% The following is enclosed to allow easy detection of differences in
% ascii coding.
% Upper-case    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
% Lower-case    a b c d e f g h i j k l m n o p q r s t u v w x y z
% Digits        0 1 2 3 4 5 6 7 8 9
% Exclamation   !           Double quote "          Hash (number) #
% Dollar        $           Percent      %          Ampersand     &
% Acute accent  '           Left paren   (          Right paren   )
% Asterisk      *           Plus         +          Comma         ,
% Minus         -           Point        .          Solidus       /
% Colon         :           Semicolon    ;          Less than     <
% Equals        =3D           Greater than >          Question mark ?
% At            @           Left bracket [          Backslash     \
% Right bracket ]           Circumflex   ^          Underscore    _
% Grave accent  `           Left brace   {          Vertical bar  |
% Right brace   }           Tilde        ~

% A couple of exemplary definitions:

\newcommand{\Nat}{{\mathbb N}}
\newcommand{\Real}{{\mathbb R}}

\def\lastname{Martins Moreira}

\begin{document}
\begin{frontmatter}
%  \title{Modeling the Java Card API (or Interface?) in B} \author{A. Martins Moreira\thanksref{ALL}\thanksref{anamaria}}
%  \address{DIMAp-UFRN, Natal, RN, Brazil} \author{S. de Oliveira Santos \thanksref{simone}}
%  \address{DIMAp-UFRN, Natal, RN, Brazil} \author{B. Emerson Gurgel Gomes \thanksref{bruno}}
%    \address{IFRN, Currais Novos, RN, Brazil} \author{D. Boris Paul D\'{e}harbe \thanksref{david}}
%      \address{DIMAp-UFRN, Natal, RN, Brazil} \thanks[ALL]{INES-CAPES-projeto GD?... o que mais?} \thanks[anamaria]{Email:
%    \href{mailto:anamaria@dimap.ufrn.br} {\texttt{\normalshape
%        anamaria@dimap.ufrn.br}}} 
%      \thanks[simone]{Email:
%    \href{mailto:simone82@ppgsc.ufrn.br} {\texttt{\normalshape
%        simone82@ppgsc.ufrn.br}}}
%      \thanks[bruno]{Email:
%    \href{mailto:bruno.gurgel@ifrn.edu.br} {\texttt{\normalshape
%        bruno.gurgel@ifrn.edu.br}}}
%       \thanks[david]{Email:
%    \href{mailto:david@dimap.ufrn.br} {\texttt{\normalshape
%        david@dimap.ufrn.br}}}

  \title{Modeling the Java Card API (or Interface?) in B}
  \author[ufrn]{A. Martins Moreira\thanksref{ALL}\thanksref{anamaria}}
  \author[ufrn]{S. de Oliveira Santos \thanksref{simone}}
  \author[ifrn]{B. Gurgel Gomes \thanksref{bruno}} \author[ufrn]{D.
    D\'{e}harbe \thanksref{david}} \address[ufrn]{DIMAp-UFRN, Natal,
    RN, Brazil} \thanks[ALL]{This work is partly supported by CAPES
    and CNPq grants 306033/2009-7, 560014/2010-4 and 573964/2008-4
    (National Institute of Science and Technology for Software
    Engineering---INES, \texttt{www.ines.org.br}).}
\address[ifrn]{IFRN, Currais Novos, RN, Brazil}
\thanks[anamaria]{Email: \href{mailto:anamaria@dimap.ufrn.br}
  {\texttt{\normalshape anamaria@dimap.ufrn.br}}}
\thanks[simone]{Email: \href{mailto:simone82@ppgsc.ufrn.br}
  {\texttt{\normalshape simone82@ppgsc.ufrn.br}}}
\thanks[bruno]{Email: \href{mailto:bruno.gurgel@ifrn.edu.br}
  {\texttt{\normalshape bruno.gurgel@ifrn.edu.br}}}
\thanks[david]{Email: \href{mailto:david@dimap.ufrn.br}
  {\texttt{\normalshape david@dimap.ufrn.br}}}


\begin{abstract} 
  The B method development process starts from an abstract model of a
  set of services that are to be developed, and proceeds with formally
  verified refinements, which introduce implementation details. At a
  final refinement step these implementation details depend on the
  language for which code is to be generated. To rigorously develop
  Java Card Applications with the B method, then, it is necessary to
  model in B the constructs of Java Card, so that the gap between the
  B formally verified implementation model and the Java Card generated
  code be as narrow as possible. In the context of the BSmart project,
  we have developed the specification of the Java Card Application
  Programming Interface (Java Card API), to be used in the development
  of Java Card applications with B.
\end{abstract}
\begin{keyword}
  Java Card, smart cards, B method, formal methods
\end{keyword}
\end{frontmatter}
\section{Introduction}\label{intro}

In the context of the BSmart project, we are interested in the use of
B to develop Java Card~\cite{chen:2000} applications.  Java Card is a
restricted and optimized version of Java which allows memory and
processor constrained devices, such as smart cards, to store and run
small applications.  Java Card applications have characteristics
(small size and need for security) which make them good candidates for
formal development with the B method. They also present some
regularity of structure that led our group to define a method and
implement a tool which specialize B for development of such
applications, providing greater support for the developer than pure B
tools \cite{atelierB,proB}. They are the BSmart method and tool,
presented in \cite{BSmart08,Gomes10}.

Previous works have also dealt with B for Smart Cards,
\cite{Bert:2003,JBtools,tatibouet:lncs,requetBtoC}, but none has, at
our knowledge, specified Java Card in B so that the formal development
includes Java Card aspects. In the first versions of BSmart
\cite{Gomes10}, these aspects were included by the code generator, and
in JBTools \cite{JBtools}, the generated code needed to be edited by
the developer to include these aspects.

These works lacked then the ability to formally verify the Java Card
dependent aspects of the application. To be able to change this, a B
specification of these aspects is needed, and this is the contribution
of this paper: the B specification of the Java Card API, with its
primitive types and all the classes of the 14 packages composing the
API. This specification can be used with the BSmart tool, 
independently, in any B tool, or even as a complement to the official
Java Card documentation \cite{oracle}.

In the following...

\section{Smart Cards and Java Card}\label{sec:javacard}


AMM: TRECHOS EXTRAIDOS E JA UM POUCO ALTERADOS DO ABZ 2010. DEPENDENDO
DO QUE VAMOS MOSTRAR NA ESPECIFICAÇAO PODEMOS DEIXAR MAIS OU MENOS
DETALHES AQUI. NO FINAL, PRECISAMOS VERIFICAR QUE NAO COPIAMOS DEMAIS
O QUE ESTAVA LA.

A smart card application is distributed between on-card and off-card
components.  The server application on the card side (called applet)
provides the application services. The off-card client (called host
application) resides in a computer or electronic terminal.

The information exchange between the host and card applications is
made through a a half-duplexed low level protocol, named
\emph{Application Protocol Data Unit} (APDU).  The ISO 7816-4 standard
specifies two kinds of APDU's, which are the command and the response
APDU (Figure~\ref{fig:APDUs}). Both specify data packets. A command APDU
is sent by the host, requiring some applet service and a response APDU is
sent by the applet, responding to the host request with the result of the
service processing.

\begin{figure}[!ht]
\centering
%\includegraphics[scale=0.3]{figs/comandoAPDU.jpg}
%\includegraphics[scale=0.3]{figs/respostaAPDU.jpg}
\caption{Command and response APDUs. Source:~\cite{ortiz1intro:2003}}
\label{fig:APDUs}
\end{figure}

The main component of the Java Card platform (Figure~\ref{fig:jcre})
is its runtime environment (JCRE), composed of a Java Card Virtual
Machine (JCVM), an API, and, usually, system and
industry-specific classes~\cite{chen:2000}. The JCRE acts as a small
operating system, being responsible for the control of the application
lifetime, security and resource management.

\begin{figure}[h]
\centering
%\includegraphics[width=0.35\textwidth]{figs/jcplatform.png}
\caption{Java Card platform components. Adapted from:~\cite{ortiz1intro:2003}}
\label{fig:jcre}
\end{figure}


\paragraph{Java Card applets}\label{sec:applets}

A Java Card applet is a class that inherits the
\emph{javacard.framewok.Applet} class of the Java Card API and is
implemented upon the Java Card subset of Java.  During the applet
conversion for card installation, a verification phase is performed to
check conformance of the classes to Java Card restrictions.

The current usual Java Card specification (2.2.x) allows two kinds of
applets.  The older, and most commonly used, kind of applet
manipulates directly the APDU protocol packages while the newer one
abstracts from the lower level protocol using Remote Method Invocation
(RMI). In this paper we will call the lower level applet \emph{APDU
  applet} and the higher level one, \emph{RMI applet}. RMI introduces
a layer of abstraction above the APDU protocol, and hence is usually
less efficient than APDU applets.


\section{B specification of the Java Card API}

Among the different components of the Java Card platform, the Java
Card API is the one without which no refinement into Java Card code
could be done.  Suppose, for instance, that we had the B abstract
machine of Fig.~\ref{lis:buscard}, which models a bus card with a
variable that keeps track of the current credit the user has
(\texttt{balance}) and an operation to add credits to this balance
(\texttt{add}). This simple example provides enough evidence of the
importance of having a B model of the Java Card API.  As all data in
it is implementable in C, for instance, and as it is a deterministic
specification, B tools can directly generate code for it in C, and the
resulting code would be very similar to the original B machine.

\lstset{language=B, caption={B machine Buscard},label=lis:buscard}
\begin{lstlisting}
MACHINE
	Buscard
CONSTANTS
	MAX_BALANCE
PROPERTIES
	MAX_BALANCE : INTEGER & MAX_BALANCE  = 100
VARIABLES
	balance
INVARIANT
	balance : INTEGER & balance <= MAX_BALANCE 
INITIALISATION
	balance := 0
OPERATIONS
	add(credit) =
	PRE
		 credit : INTEGER & credit > 0  & credit <= MAX_BALANCE &
                balance + credit <= MAX_BALANCE 
	THEN
		balance := balance + credit
	END
END
\end{lstlisting}

However, Java Card code corresponding to the operation \texttt{add} of
this B specification would look like the one presented in
Fig.~\ref{lis:addjavacard}. In a rigorous development process, we do
not want the code generator to carry out all these non-verified
transformations in the code. So, we need to be able to refine the
original B machine into something such as the B refinement of
Fig.~\ref{lis:addimplementation}. Then, code generation would be
straightforward (as it should be).

\lstset{language=Java, caption={Method add in applet Java Card},label=lis:addjavacard}
\begin{lstlisting}
public void add (APDU apdu) { 
	byte[] bf;  byte cr; byte apdu_state; short res;
			
	bf = apdu.getBuffer();
	apdu_state = apdu.getCurrentState();
			
	if (apdu_state == STATE_INITIAL) {
		res = apdu.setIncomingAndReceive();
	} else if (ISO7816.OFFSET_CDATA >= 0 && 
			(short) (ISO7816.OFFSET_CDATA + 2) <= bf.length && 
			bf != null) {
				
		cr = Util.getShort (bf, ISO7816.OFFSET_CDATA);
				
		if (!(cr <= MAX_BALANCE)) {
			ISOException.throwIt(EX_CREDIT_EXCEEDED);
		} else if (!((short) (balance + cr) <= MAX_BALANCE)) {
			ISOException.throwIt(EX_BALANCE_EXCEEDED);
		} else if (!((short) (balance + cr) >= 0)) {
			ISOException.throwIt(EX_NEGATIVE_BALANCE);
		} else if (! (cr > 0)) {
			ISOException.throwIt(EX_NEGATIVE_CREDIT);
		} else {
			balance = (short) (balance + cr);
		}
	} 
}
\end{lstlisting}

\lstset{language=B, caption={B implementation},label=lis:addimplementation}
\begin{lstlisting}
add (apdu) = 
VAR 
	bf, cr, apdu_state, res
IN
	bf  <-- apdu.getBuffer;		
    	apdu_state  <-- apdu.getCurrentState;
	    
	IF (apdu_state = STATE_INITIAL) 
	THEN
		res <-- apdu.setIncomingAndReceive                
	ELSIF (OFFSET_CDATA >= 0 &
		sum_short(OFFSET_CDATA, 2) <= size(bf) & 
		bf /= [])
	THEN 
		cr  <-- Util.getShort(bf, OFFSET_CDATA);
		    
		IF not (cr <= MAX_BALANCE)
		THEN 
			ISOException.throwIt(EX_CREDIT_EXCEEDED)
		ELSIF not (sum_short (balance, cr) <= MAX_BALANCE)
		THEN 
			ISOException.throwIt(EX_BALANCE_EXCEEDED)
		ELSIF not (sum_short (balance, cr) >= 0)
		THEN ISOException.throwIt(EX_NEGATIVE_BALANCE)
		ELSIF not (cr > 0)
		THEN ISOException.throwIt(EX_NEGATIVE_CREDIT) 
		ELSE  
			balance := sum_short(balance, cr)
		END
	END
END
\end{lstlisting}


We can identify two main kinds of transformation that have to be
carried out in order to obtain the code of operation \texttt{add} in
figs.~\ref{lis:addjavacard} and~\ref{lis:addimplementation} from the
abstract specification in fig.~\ref{lis:buscard}:

\begin{enumerate}
\item the transition into a defensive style of programming by the
  inclusion of explicit tests to check that the input conditions (pre
  conditions in the B specification) are satisfied before executing
  the corresponding action;

\item the inclusion of Java Card specific aspects, such as changing
  the signature of \texttt{add} so that data is transmitted via the
  APDU protocol and the APDU buffer is manipulated by methods offered
  the Java Card API.

\end{enumerate}

The transition to a defensive style of programming is part of the
BSmart method, and implemented by the BSmart Full Function
component. This component generates a B refinement of the original
specification where pre-conditions are transformed into conditionals
(IF-THEN-ELSE-END constructs), with the indication of the need to
throw the corresponding exception when the specified conditions are
not met by input data and states.  The resulting B model can then be
formally verified as usual in the B method.

The change of interface is also taken care of by the BSmart method, so
that the development can be done without need to extend the B
method, as detailed in~\cite{Gomes10}.

But all of these transformations rely on the need to reference Java
Card API types, classes and methods on the B level.  This is then the
reason why the Java Card API needed to be the first Java Card
component to be modeled in B.

[[[(PARA SIMONE e BRUNO: maybe also cite related work ? Which are the formalization works that did not focus on the API?)]]]

[[[ PARA SIMONE -> tambem precisamos com urgencia daquela analise sobre o que muda da 2.2.2 para a 3 ]]]


The Java Card API, in its version 2.2.2\footnote{Java Card 2.2.2,
  although not the most recent version of the Java Card platform, is
  still widely used, and can easily be extended to Java Card 3 Classic
  Edition, a backward compatible evolution of version 2.2.2.,
  including some bug fixes, clarifications against the Java Card
  v2.2.2 specifications and new security algorithms (Java Card 3
  Platform Release Notes, available at
  http://www.oracle.com/technetwork/java/javame/javacard/download/overview/index.html).}, is composed of 14
packages, containing 93 classes and interfaces, as shown in
Table~\ref{tab:packages}. Their interfaces have all been modeled in B,
and the resulting models are available at the KitSmart project
page\footnote{https://code.google.com/p/kitsmart/}.  Differently from
JML and OCL, though, B is not object oriented, and some modeling
solutions had to be found to cope with this lack of resources.  We
present in the following the main characteristics and some
restrictions of our models:

\begin{table}[h]
\begin{center}
\caption{Packages of the Java Card API (2.2.2) and the number of classes in each package.}
\begin{tabular}{|l|c||l|c|}
 \hline
 
\textbf{\small{Package}} & \textbf{\small{classes}} & \textbf{\small{Package}} & \textbf{\small{classes}}\\ \hline \hline
\small{java.io} & \small{1} & \small{javacardx.biometry} & \small{5} \\ \hline
\small{java.lang} & \small{12} & \small{javacardx.crypto }& \small{2} \\ \hline
\small{java.rmi} & \small{2} & \small{javacardx.external} & \small{3} \\ \hline
\small{javacard.framework} & \small{19} & \small{javacardx.framework.math} & \small{3} \\ \hline
\small{javacard.framework.service} & \small{8} & \small{javacardx.framework.tlv} & \small{7} \\ \hline
\small{javacard.security} & \small{27} & \small{javacardx.framework.util} & \small{2} \\ \hline
\small{javacardx.apdu} & \small{1} & \small{javacardx.framework.util.intx} & \small{1} \\

 \hline
\end{tabular}
\label{tab:packages}
\end{center}
\end{table}

\begin{itemize}

\item Only the abstract models corresponding to each class or
  interface have been developed. Two reasons led to this choice: (1)
  code is not to be generated from the specification of the API, as we
  are only creating an abstract layer to existing implementations; and
  (2) in B, only the abstract machines are seen by modules that build
  upon others, through the SEES, USES, IMPORTS, INCLUDES and EXTENDS
  clauses.

\item Conditions on method inputs which may lead to exception raising
  in the Java Card platform specification are coded into
  pre-conditions in B.
  
\item Method outputs are modeled in B as taking any value of the
  correct type, or, when possible in the current abstraction level,
  any value of a more restricted set of specified return values.
  
\item Each machine corresponding to a Java Card class defines an
  abstract set with the same name (distinction on character cases,
  only). For instance, the machine Throwable declares the abstract set
  THROWABLE. This set can then be used to reference the type
  corresponding to the class.

\item The hierarchy of the Java Card API objects is partially modeled
  by abstract set inclusion. For instance, the class Throwable extends
  the class Object, in Java Card. In our model, we also have that the
  machine Throwable EXTENDS the machine Object, but the meaning of a
  machine extension in B is different from the meaning of a class
  extension in Java Card. To show that all throwables are indeed
  objects, a property stating that THROWABLE is a subset of OBJECT is
  included in the Throwable machine.

\item Overloading is not allowed in B and occurs frequently in Java
  Card. To model overloaded methods in B an extension to overloaded
  method names was included. We then have equals, equals\_1,
  equals\_2, etc.
\end{itemize}

As previously stated, we chose to model exception raising conditions
as operation pre-conditions in the B models. For instance, if the Java
Card specification states that a method should throw an exception in
case a parameter array is empty, the pre-condition of the
corresponding B operation will require that this parameter is not
empty. The B method then requires that every call to that operation
satisfies the operation's pre-condition. As a consequence, code that
is formally generated using the B method and the Java Card API
specification should never raise this specific exception, as it is
statically proved that all calls to this operation are made with
non-empty parameter arrays. Not all situations leading to exceptional
conditions are modeled, however, as some of them depend on the Java
Card Runtime Environment (JCRE) and its state, which has not yet been
modeled, and some require a more detailed specification of the
contents of some data and other internal behavior. In these cases, the
exception raising conditions are only left as comments to the B
specification, and can be used as additional documentation or to be
considered in future work.

One delicate issue to be dealt with both by the user of the API
specification and the tools designed to work with it, is the use of
overloaded methods in an application development. When overloaded
operations are used in an application development, the user must
explicitly choose which version of the overloaded operation is to be
used. Then, verifications will be carried out considering this
specific version of the operation. When code is generated, either the
code generator will remove the name extension automatically, if
designed for it, or the user will have to edit the generated code
manually. In any case, it is important that the actual method called
in the Java Card code is the one with which verifications have been
carried out.  In case of overriding, in particular, it will be either
the user's responsibility to choose the B one which is in scope at
this specific point in Java, or an extra verification step will be
included in the code generator to check that the operation used in
B is the one in scope in Java and registers an error in case it is
not.

[[[ incluir aqui parte da discussao sobre as opcoes de modelagem  com o argumento pela escolha dos subsets para a tipagem ]]] 
As our focus was on the interfaces of the Java Card API methods, 



\section{Using the model in BSmart}



\section{Conclusions and future work}

With the current level of abstraction of the model and the fact that
the Java Card Runtime Environment (JCRE) has not been modeled, some
conditions which may lead to exception raising are not yet
modeled. Being able to model them would make developed applications
even more sure, as more static verification could be carried
out. Continuation of this work then will enlarge the scope of the
modeling to cope statically with a larger set of situations.


\bibliographystyle{plain}
\bibliography{bib}

\end{document}
